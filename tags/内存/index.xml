<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内存 on ARAE</title><link>https://arae.cc/tags/%E5%86%85%E5%AD%98.html</link><description>Recent content in 内存 on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 12 Jul 2016 19:24:39 +0800</lastBuildDate><atom:link href="https://arae.cc/tags/%E5%86%85%E5%AD%98/index.xml" rel="self" type="application/rss+xml"/><item><title>内存映射文件处理大文件</title><link>https://arae.cc/post/25705.html</link><pubDate>Tue, 12 Jul 2016 19:24:39 +0800</pubDate><guid>https://arae.cc/post/25705.html</guid><description>内存映射文件处理大文件 // 创建文件内核对象，其句柄保存于hFile HANDLE hFile = CreateFile(“Recv1.zip”,GENERIC_WRITE | GENERIC_READ,FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL); // 创建文件映射内核对象，句柄保存于hFileMapping HANDLE hFileMapping = CreateFileMapping(hFile,NULL,PAGE_READWRITE, 0, 0x4000000, NULL); // 释放文件内核对象 CloseHandle(hFile); // 设定大小、偏移量等参数 __int64 qwFileSize = 0x4000000; __int64 qwFileOffset = 0; __int64 T = 600 * sinf.dwAllocationGranularity; DWORD dwBytesInBlock = 1000 * sinf.dwAllocationGranularity; // 将文件数据映射到进程的地址空间 PBYTE pbFile = (PBYTE)MapViewOfFile(hFileMapping,FILE_MAP_ALL_ACCESS,(DWORD)(qwFileOffset &amp;gt;&amp;gt;32), (DWORD)(qwFileOffset&amp;amp;0xFFFFFFFF), dwBytesInBlock); while(bLoop) { // 捕获事件hEvent[0]和事件hEvent[1] DWORD ret = WaitForMultipleObjects(2, hEvent, FALSE, INFINITE); ret -= WAIT_OBJECT_0; switch (ret) { // 接收数据事件触发 case 0: // 从端口接收数据并保存到内存映射文件 nReadLen=syio_Read(port[1], pbFile + qwFileOffset, QueueLen); qwFileOffset += nReadLen; // 当数据写满%时，为防数据溢出，需要在其后开辟一新的映射视图 if (qwFileOffset &amp;gt; T) { T = qwFileOffset + 600 * sinf.dwAllocationGranularity;UnmapViewOfFile(pbFile); pbFile = (PBYTE)MapViewOfFile(hFileMapping,FILE_MAP_ALL_ACCESS,(DWORD)(qwFileOffset&amp;gt;&amp;gt;32), (DWORD)(qwFileOffset&amp;amp;0xFFFFFFFF), dwBytesInBlock); } break; // 终止事件触发 case 1: bLoop = FALSE; // 从进程的地址空间撤消文件数据映像 UnmapViewOfFile(pbFile); // 关闭文件映射对象 CloseHandle(hFileMapping); break; } }… 在终止事件触发处理过程中如果只简单的执行UnmapViewOfFile()和CloseHandle()函数将无法正确标识文件 的实际大小，即如果开辟的内存映射文件为GB，而接收的数据只有GB，那么上述程序执行完后，保存的文 件长度仍是GB。也就是说，在处理完成后还要再次通过内存映射文件的形式将文件恢复到实</description></item></channel></rss>