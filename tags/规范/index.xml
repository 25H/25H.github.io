<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>规范 on ARAE</title><link>https://blog.arae.cc/tags/%E8%A7%84%E8%8C%83.html</link><description>Recent content in 规范 on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 02 Mar 2018 19:09:22 +0800</lastBuildDate><atom:link href="https://blog.arae.cc/tags/%E8%A7%84%E8%8C%83/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP协议状态码</title><link>https://blog.arae.cc/post/25777.html</link><pubDate>Fri, 02 Mar 2018 19:09:22 +0800</pubDate><guid>https://blog.arae.cc/post/25777.html</guid><description>HTTP状态码 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头(server header)用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 1xx 信息/临时响应 表示临时响应并需要请求者继续执行操作的状态代码。 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。 100 Continue 状态：继续 说明：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols 状态：切换协议 说明：请求者已要求服务器切换协议，服务器已确认并准备切换。 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不</description></item><item><title>为什么谷歌要执行严格的代码编写规范</title><link>https://blog.arae.cc/post/25725.html</link><pubDate>Fri, 15 Jul 2016 13:23:10 +0800</pubDate><guid>https://blog.arae.cc/post/25725.html</guid><description>我们在谷歌所做事情中另外一个让我感到异常有效、有用的制度是严格的编码规范。 在到Google工作之前，我一直认为编码规范没有什么用处。我坚信这些规范都是官僚制度下产生的浪费大家的编程时间、影响人们开发效率的东西。 我是大错特错了。 在谷歌，我可以查看任何的代码，进入所有谷歌的代码库，我有权查看它们。事实上，这种权限是很少人能拥有的。但是，让我感到惊讶的却是，如此多的编码规范—缩进，命名，文件结构，注释风格—这一切让我出乎意料的轻松的阅读任意一段代码，并轻易的看懂它们。这让我震惊—因为我以为这些规范是微不足道的东西。它们不可能有这么大的作用—但它们却起到了这么大的作用。当你发现只通过看程序的基本语法结构就能读懂一段代码，这种时间上的节省不能不让人震撼！ 反对编码规范的人很多，下面是一些常见的理由，对于这些理由，我以前是深信不疑。 这是浪费时间！ 我是一个优秀的程序员，我不愿意浪费时间干这些愚蠢的事。我的技术很好，我可以写出清晰的、易于理解的代码。为什么我要浪费时间遵守这些愚蠢的规范？答案是：统一是有价值的。就像我前面说的—你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差</description></item></channel></rss>