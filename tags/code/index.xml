<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code on ARAE</title><link>https://blog.arae.cc/tags/code.html</link><description>Recent content in Code on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 26 Jul 2018 20:51:45 +0800</lastBuildDate><atom:link href="https://blog.arae.cc/tags/code/index.xml" rel="self" type="application/rss+xml"/><item><title>前端上传图片并实现预览</title><link>https://blog.arae.cc/post/25793.html</link><pubDate>Thu, 26 Jul 2018 20:51:45 +0800</pubDate><guid>https://blog.arae.cc/post/25793.html</guid><description>在实际项目应用中，经常会使用到上传图片，并且可以让用户直接预览图片。对于此种做法有两种方法可以实现：一是前后台交互，后台将图片地址返回前端； 二是，使用FileReader对象——允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容；此种方法可以优化图片加载速度，减少方法一占用带宽的问题； &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;js/jquery-1.8.3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt; &amp;lt;img class=&amp;quot;img&amp;quot; id=&amp;quot;img&amp;quot; src=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt; &amp;lt;script&amp;gt; var File = document.getElementById(&#39;file&#39;); File.onchange = function(e){ var file = this.files[0]; console.log(this.files[0]) var reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = function (e) { console.log(e.target) document.getElementById(&#39;img&#39;).setAttribute(&amp;quot;src&amp;quot;,e.target.result); //e.target.result就是最后的路径地址 }; } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 关键是reader.readAsDataURL(file)这句，可以把图片转成base64格式，让img标签读取</description></item><item><title>JavaScript如何判断变量是数组还是对象</title><link>https://blog.arae.cc/post/25792.html</link><pubDate>Fri, 15 Jun 2018 15:26:38 +0800</pubDate><guid>https://blog.arae.cc/post/25792.html</guid><description>方法一 通过判断变量的类型，并且变量的length属性(除了有一种例外是arguments对象–当给函数传参时数据存储的地方) var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(typeof arr); //object console.log(typeof obj); //object console.log(arr.length); //3 console.log(obj.length); //undefined console.log(obj.name); //maomao //这里说明在对象中并没有length属性，所以是未定义。 方法二 使用toString方法将对象转换成其他类型的string，该例很好的证明了arguments对象不是数组，而是对象 var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; // console.log(arr.toString()); //&#39;2,3,4&#39; // console.log(obj.toString()); //[object Object] function sum(a,b){ // console.log(arguments); // console.log(typeof arguments); //object // console.log(arguments.length); //2 根据具体调用函数传的实参决定 // console.log(arguments.toString()); //[object Arguments] return a+b; } alert(sum(3,4)); 方法三 —&amp;gt;不可行 instanceof 指出对象是否是特定类的一个实例。 结论:instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(arr instanceof Array); //true console.log(obj instanceof Object); //true console.log(arr instanceof Object); //true // ---这里跟网上的不同，不知道是什么原因 console.log(obj instanceof Array); //false 方法四 ECMAScript 5中可以使用isArray来判断 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(Array.isArray(arr)); //true console.log(Array.isArray(obj)); //false //注意没有isObject这种方法 暂时 方法五 使用isPrototypeOf()函</description></item><item><title>H5 video 视频标签属性详解</title><link>https://blog.arae.cc/post/25788.html</link><pubDate>Sat, 05 May 2018 17:46:18 +0800</pubDate><guid>https://blog.arae.cc/post/25788.html</guid><description>前言 HTML5标签video在PC上显示很简单，就一个标签加资源，很少需要关心其它属性。但放到移动设备上，video的标准，Android和ios有很多区别，另外还有很多各家浏览器特定的属性. video属性 &amp;lt;video id=&amp;quot;video&amp;quot; src=&amp;quot;video.mp4&amp;quot; controls = &amp;quot;true&amp;quot; poster=&amp;quot;images.jpg&amp;quot; /* 视频封面 */ preload=&amp;quot;auto&amp;quot; webkit-playsinline=&amp;quot;true&amp;quot; /* 这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放 */ playsinline=&amp;quot;true&amp;quot; /* IOS微信浏览器支持小窗内播放 */ x-webkit-airplay=&amp;quot;allow&amp;quot; x5-video-player-type=&amp;quot;h5&amp;quot; /* 启用H5播放器,是wechat安卓版特性 */ x5-video-player-fullscreen=&amp;quot;true&amp;quot; /* 全屏设置，设置为 true 是防止横屏 */ x5-video-orientation=&amp;quot;portraint&amp;quot; /* 播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏 */ style=&amp;quot;object-fit:fill&amp;quot;&amp;gt; &amp;lt;/video&amp;gt; src: 视频的地址 controls: 加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 poster: 属性规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。如果未设置该属性，则使用视频的第一帧来代替。 preload: 属性规定在页面加载后载入视频。 webkit-playsinline和playsinline: 视频播放时局域播放，不脱离文档流 。但是这个属性比较特别， 需要嵌入网页的APP比如WeChat中UIwebview 的allowsInlineMediaPlayback = YES webview.allowsInlineMediaPlayback</description></item><item><title>200行JS代码实现超级简单的区块链</title><link>https://blog.arae.cc/post/25783.html</link><pubDate>Tue, 20 Mar 2018 10:35:20 +0800</pubDate><guid>https://blog.arae.cc/post/25783.html</guid><description>市面上有一个关于区块链的白皮书，有200多页，实在太长看不下去，本文通过JavaScript源码实现一个简单的区块链框架，带你入门区块链的相关知识。 区块链的基本概念非常简单：一个分布式数据库维持不断增长的有序记录列表。然而当我们谈论区块链时，我们也会谈论我们用区块链所要解决的问题，这二者通常很容易弄混淆。流行的基于区块链的项目如比特币和以太坊就是这种情况 。术语“区块链”通常与交易、智能合约或加密货币等概念紧密相关。 这使得理解区块链是一项必然要艰巨的任务。特别是源码级别的理解。在这里，我将介绍一个使用200行代码实现的超级简单的区块链——NaiveChain。 块结构 第一个逻辑步骤是确定块结构。为了让事情尽可能简单，我们只包含最必要的：索引(index)，时间戳(timestamp)，数据(data)，哈希(hash)和上一个哈希(previousHash)。 class Block { constructor(index, previousHash, timestamp, data, hash) { this.index = index; this.previousHash = previousHash.toString(); this.timestamp = timestamp; this.data = data; this.hash = hash.toString(); } } 块哈希 该块需要被哈希运算以保持数据的完整性。SHA-256被用来做哈希算法处理块的内容。需要注意的是这个哈希与“挖矿” 无关，因为没有解决工作量证明(Proof Of Work )的问题。 var calculateHash = (index, previousHash,</description></item><item><title>Bing每日壁纸API接口「十个国家版本」</title><link>https://blog.arae.cc/post/25782.html</link><pubDate>Wed, 14 Mar 2018 23:49:26 +0800</pubDate><guid>https://blog.arae.cc/post/25782.html</guid><description>前言 (瞎BB..) 这次在原有的国内版(中国)、国际版(美国)基础上又加了日本、印度、巴西、法国、德国、加拿大、澳大利亚、英国八个地区版本，不过就是图片重复率有点高，建议随便选个一直用@pp{你懂的} 接口在调用的时候空参数默认为「国际版(美国)302到图片地址」，而且POST方法仅支持返回JSON。 接口(API) 接口： //api.arae.cc/?p=bing 参数： s 地区版本，默认 0 ，可空 0 =&amp;gt; 美国 EN-US 1 =&amp;gt; 中国 ZH-CN 2 =&amp;gt; 日本 JA-JP 3 =&amp;gt; 印度 EN-IN 4 =&amp;gt; 巴西 PT-BR 5 =&amp;gt; 法国 FR-FR 6 =&amp;gt; 德国 DE-DE 7 =&amp;gt; 加拿大 EN-CA 8 =&amp;gt; 澳大利亚 EN-AU 9 =&amp;gt; 英国 EN-GB code json = 返回utf8 json数据(包括日期、地址、说明); null/undefined 或 其他则自动302到图片地址(可直接img标签调用); key 其实这个打算写出来自己用的，如果想用可以到留言板留言...具体格式参照api.arae.cc首页申请格式.. 返回参数说明 { &amp;quot;time&amp;quot;:&amp;quot;20180313&amp;quot;, /* 时间 */ &amp;quot;startdate&amp;quot;:&amp;quot;2018-03-13&amp;quot;, /* 开始时间 */ &amp;quot;enddate&amp;quot;:&amp;quot;2018-03-14&amp;quot;, /* 结束时间 */ &amp;quot;region&amp;quot;:&amp;quot;ZH-CN&amp;quot;, /* 缩写 */ &amp;quot;url&amp;quot;:&amp;quot;***.jpg&amp;quot;, /* 图片链接 */ &amp;quot;text&amp;quot;:&amp;quot;****&amp;quot; /* 图片相关说明 */ } 调用方法 GET: 返回 「中国版」 json数据(utf8) //api.arae.cc/?p=bing&amp;amp;code=json&amp;amp;s=1 { &amp;quot;time&amp;quot;:&amp;quot;20180313&amp;quot;, &amp;quot;startdate&amp;quot;:&amp;quot;2018-03-13&amp;quot;, &amp;quot;enddate&amp;quot;:&amp;quot;2018-03-14&amp;quot;, &amp;quot;region&amp;quot;:&amp;quot;ZH-CN&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/ToroidalBubble_ZH-CN10711997835_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;小巴哈马浅滩中的大西洋花斑原海豚和气泡环，巴哈马 (© Hiroya Minakuchi/Minden Pictures)&amp;quot; } 返回 「美国版」 json数据(utf8) //api.arae.cc/?p=bing&amp;amp;code=json { &amp;quot;time&amp;quot;:&amp;quot;20180314&amp;quot;, &amp;quot;startdate&amp;quot;:&amp;quot;2018-03-14&amp;quot;, &amp;quot;enddate&amp;quot;:&amp;quot;2018-03-15&amp;quot;, &amp;quot;region&amp;quot;:&amp;quot;EN-US&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/ToroidalBubble_EN-US9481815479_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;Atlantic spotted dolphins</description></item><item><title>Bing每日图片(壁纸)API接口</title><link>https://blog.arae.cc/post/25776.html</link><pubDate>Tue, 27 Feb 2018 00:22:20 +0800</pubDate><guid>https://blog.arae.cc/post/25776.html</guid><description>前言 (瞎BB..) [NEW] Bing每日壁纸API接口「十个国家版本」 Bing图片每日更新，对于这一点感觉挺不错的，如果能够把Bing每日图片作为博客背景是不是很不错呢？ 在用的时候注意区分下国内版跟国际版，有时候图片一样，但是描述全是鸟文&amp;hellip; 接口在调用的时候空参数默认为(国内版302到图片地址)，而且POST方法仅支持返回JSON。 接口(API) 接口： //api.arae.cc/?p=bing 参数： s 1 = 国内; null/undefined 或 其他值:国际版; code json = 返回utf8 json数据(包括日期、地址、说明); null/undefined 或 其他则自动302到图片地址(可直接img标签调用); key 其实这个打算写出来自己用的，如果想用可以到留言板留言...具体格式参照api.arae.cc首页申请格式.. PS:分辨率是 1920x1080 调用方法 GET: 返回 [国内版] json数据(utf8) //api.arae.cc/?p=bing&amp;amp;s=1&amp;amp;code=json { &amp;quot;time&amp;quot;:&amp;quot;20180226&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/CactiIslaPescado_ZH-CN11317505000_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;玻利维亚乌尤尼盐湖的仙人掌岛 (? Alex Saberi/Getty Images)&amp;quot; } 返回 [国际版] 版json数据(utf8) //api.arae.cc/?p=bing&amp;amp;code=json { &amp;quot;time&amp;quot;:&amp;quot;20180226&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/WoolBaySeadragon_EN-US12559454946_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;A leafy seadragon in the waters off Wool Bay, Australia (? Alex Mustard/Minden Pictures)&amp;quot; } 返回 [国内版] 图片 //api.arae.cc/?p=bing&amp;amp;s=1 Html: &amp;lt;img src=&amp;quot;//api.arae.cc/?p=bing&amp;amp;s=1&amp;quot; title=&amp;quot;Bing每日图片(壁纸) 国内版&amp;quot;&amp;gt; Markdown: ![&amp;quot;Bing每日图片(壁纸) 国内</description></item><item><title>注释用的好，可能会挨打！？</title><link>https://blog.arae.cc/post/25773.html</link><pubDate>Fri, 23 Feb 2018 17:19:04 +0800</pubDate><guid>https://blog.arae.cc/post/25773.html</guid><description>一、概述 这是写在前面的话：在开发中的时候，应该、可能、或许会看到有趣的注释 遇到类似的注释能让开发更加的有乐趣，我提倡程序猿继续传承下去这个美好优良传统 二、正文 比如： /** * 描述：XXXX &amp;lt;br&amp;gt; * 作者： XXXX &amp;lt;br&amp;gt; * E-mail: XXXX &amp;lt;br&amp;gt; * 日期： XXXX 下午XXXX &amp;lt;br&amp;gt; */ public class Points implements Serializable { private static final long serialVersionUID = 1L; /** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&amp;quot; &amp;quot;-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &amp;gt; &amp;quot;=._ | )(__/ \__)( | _.=&amp;quot; &amp;lt; | * * | (_/&amp;quot;=._&amp;quot;=._ |/ /\ \| _.=&amp;quot;_.=&amp;quot;\_) | * * | &amp;quot;=._&amp;quot;(_ ^^ _)&amp;quot;_.=&amp;quot; | * * | &amp;quot;=\__|IIIIII|__/=&amp;quot; | * * | _.=&amp;quot;| \IIIIII/ |&amp;quot;=._ | * * | _ _.=&amp;quot;_.=&amp;quot;\ /&amp;quot;=._&amp;quot;=._ _ | * * | ( \_.=&amp;quot;_.=&amp;quot; `--------` &amp;quot;=._&amp;quot;=._/ ) | * * | &amp;gt; _.=&amp;quot; &amp;quot;=._ &amp;lt; | * * | (_/ \_) | * * | | * * &#39;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#39; * * * * LASCIATE OGNI SPERANZA, VOI CH&#39;ENTRATE * ************************************************************** */ /** * 请不要尝试修改属性lng和lat为别的数据类型，相信我，改了之后，你会后悔的。 * 至于原因，创建的时候我应该知道，现在只剩下上帝知道 */ private Integer id; private String markerId; // 标识符 private double lng; private double lat; private String type; private Integer status = 0; // 覆盖物状态：0未添加，1已添加，2已添加并且是已发送的覆盖物 默认值：0 private List&amp;lt;Points&amp;gt; list = new ArrayList&amp;lt;Points&amp;gt;(); ...... 再或者在结尾处加 /* * ┏┓ ┏┓ *┏┛┻━━━┛┻┓ *┃ ┃ *┃ ━ ┃ *┃ ┳┛ ┗┳ ┃ *┃ ┃ *┃ ┻ ┃ *┃ ┃ *┗━┓ ┏━┛ * ┃ ┃神兽保佑 * ┃ ┃代码无BUG！ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫</description></item><item><title>jquery判断图片或者背景图片加载完毕</title><link>https://blog.arae.cc/post/25771.html</link><pubDate>Thu, 15 Feb 2018 13:37:24 +0800</pubDate><guid>https://blog.arae.cc/post/25771.html</guid><description>前端开发制作中有需要需要等到页面中的图片加载完毕后才执行某些事件，而使用jquery的load事件只是dom执行完毕，图片未必加载完成，如果要判断图片加载完毕，需要在图片标签上判断。 使用JavaScript判断图片加载完毕，如果图片在页面中的某个img标签中的话，可以用下面这个 $(&#39;img&#39;).on(&#39;load&#39;, function() { alert(&#39;new image loaded: &#39; + this.src); }); 原生js imgNode.onload = () =&amp;gt; { alert(&#39;new image loaded: &#39; + this.src); }; （1）、单张图片（图片在文档中） // HTML &amp;lt;img id=&#39;pic&#39; src=&amp;quot;../03.png&amp;quot;&amp;gt; //js $(document).ready(function(){ //jquery $(&#39;#pic&#39;).load(function(){ // 加载完成 }); //原生 onload var pic = document.getElementById(&#39;pic&#39;) pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; }) 注： 1、IE8及以下版本不支持onload事件，但支持onreadystatechange事件； 2、readyState是onreadystatechange事件的一个状态，值为loaded或complete的时候，表示已经加载完毕。 3、如果引入jquery库可以考虑直接使用jquery的load事件来解决兼容问题。 （2）、单张图片（图片动态生成） //js var pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; //jquery $(&#39;&amp;lt;img/&amp;gt;&#39;).attr(&#39;src&#39;, &#39;../03.png&#39;).on(&#39;load&#39;, function() { $(this).remove(); // 防止内存泄露 //图片加载完毕 }); （3）、单张图片（结合ES6 Promise） //js new Promise((resolve, reject)=&amp;gt;{ let pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = function(){ // 加载完成 resolve(pic) } }).then((pic)=&amp;gt;{ //code }) （4）、多张图片 var img = [], flag = 0,</description></item><item><title>PHP导出Excel、CSV文件，并解决显示不正常等问题</title><link>https://blog.arae.cc/post/25765.html</link><pubDate>Mon, 09 Oct 2017 19:23:11 +0800</pubDate><guid>https://blog.arae.cc/post/25765.html</guid><description>最近一直在折腾PHP，无意间想实现个导出表格的功能。 不料用了header声明后的表格中文是乱码的，后来通过转字符、添加字母符号、style等方法才得以让excel导出后显示正常了。 为了解决部分MySQL环境设置问题，又添加了一个CSV的导出方法。 导出Excel代码 header(&amp;quot;Content-type:application/vnd.ms-excel;charset=UTF-8&amp;quot;); header(&amp;quot;Content-Disposition:attachment;filename=xxxxx.xls&amp;quot;); //输出标题 echo &amp;quot;&amp;lt;table border=&#39;1&#39;&amp;gt;&amp;quot;; echo &amp;quot;&amp;lt;th&amp;gt;&amp;quot;.mb_convert_encoding($str, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;).&amp;quot;&amp;lt;/th&amp;gt;&amp;quot;; echo &amp;quot;&amp;lt;th&amp;gt;&amp;quot;.mb_convert_encoding($str, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;).&amp;quot;&amp;lt;/th&amp;gt;&amp;quot;; echo &amp;quot;&amp;lt;th&amp;gt;&amp;quot;.mb_convert_encoding($str, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;).&amp;quot;&amp;lt;/th&amp;gt;&amp;quot;; #.... //输出每行的内容 for ($i=0; $i &amp;lt; count($Data); $i++) { echo &amp;quot;&amp;lt;tr&amp;gt;&amp;quot;; for ($n=0; $n &amp;lt; count($Data[$i]); $n++) { //添加 style=&#39;vnd.ms-excel.numberformat:@&#39; 将内容作为字符串识别 echo &amp;quot;&amp;lt;td style=&#39;vnd.ms-excel.numberformat:@&#39;&amp;gt;&amp;quot;; echo mb_convert_encoding($Data[$i][$n],&amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;); echo &amp;quot;&amp;lt;/td&amp;gt;&amp;quot;; } echo &amp;quot;&amp;lt;/tr&amp;gt;&amp;quot;; } echo &amp;quot;&amp;lt;/table&amp;gt;&amp;quot;; 导出CSV代码 /** * 导出CSV文件 * @param string $fileName 文件名字 * @param string|array $data 导出数据，csv格式的字符串|数值数组 * @param string $to_encoding 目标转换编码 * @param string $from_encoding 当前编码 */ function exportCSV($fileName = &#39;&#39;, $data = &#39;&#39;, $to_encoding = &#39;gb2312&#39;, $from_encoding = &#39;utf-8&#39;) { $fileName = empty($fileName) ? date(&#39;YmdHis&#39;) : $fileName; // 文件标签 Header(&amp;quot;Content-type: application/octet-stream&amp;quot;); header(&amp;quot;Content-type: application/vnd.ms-excel; charset=$from_encoding&amp;quot;); Header(&amp;quot;Content-Disposition: attachment; filename=$fileName.csv&amp;quot;); $str = &#39;&#39;; if($data) { if(is_array($data)) { foreach ($data as $v) { if(is_array($v)) { foreach ($v as $vo) { $str .= (is_numeric($vo) ? &amp;quot;&#39;&amp;quot;.$vo : $vo.&amp;quot;&amp;quot;).&amp;quot;,&amp;quot;; } $str = trim($str, &amp;quot;,&amp;quot;).&amp;quot;\r\n&amp;quot;; } else { $str .= (is_numeric($v) ? &amp;quot;&#39;&amp;quot;.$v : $v).&amp;quot;,&amp;quot;; } } $str = trim($str, &amp;quot;,&amp;quot;).&amp;quot;\r\n&amp;quot;; } else { $str = $data; } } echo mb_convert_encoding($str, &amp;quot;gb2312&amp;quot;, &amp;quot;utf-8&amp;quot;); exit; } exportCSV($fileName=$str,$data = $Data); ?&amp;gt;</description></item><item><title>8行代码在Python3中实现多核并行执行</title><link>https://blog.arae.cc/post/25767.html</link><pubDate>Thu, 21 Sep 2017 16:41:38 +0800</pubDate><guid>https://blog.arae.cc/post/25767.html</guid><description>python作为一个简单的脚本语言在工作中会经常用到，但奈何执行大量重复性任务时单线程效率低下，这时可以通过多线程并行执行大大提高代码执行效率。 Python3多核并行执行完整示例：（可以复制粘贴到IDLE运行一下） import threading, time from queue import Queue def basic_worker(queue): while True: item = queue.get() print(str(item)+&amp;quot;\r\n&amp;quot;) queue.task_done() def basic(): ts = time.time() queue = Queue() for i in range(3): t = threading.Thread(target=basic_worker,args=(queue,)) t.daemon = True t.start() for item in range(100): #创建任务队例 queue.put(item) queue.join() print(&#39;Took {}&#39;.format(time.time() - ts)) #执行结束，输出执行时长 if __name__ == &#39;__main__&#39;: basic() 并行计算主要是通过下面这8行代码来实现的： queue = Queue() #初始化一个队例 for i in range(3): t = threading.Thread(target=basic_worker,args=(queue,)) t.daemon = True t.start() for item in range(100): #创建任务队例 queue.put(item) queue.join() 上面的代码创建了3个线程（具体线程数量可根据任务复杂度及机器配置进行调整），并通过queue.put(item) 写入任务队例及所需参数，最后通过queue.join() 方法告诉程序queue写入完毕开始执行队例。 记得将basic_worker() 方法内的代码替换为你所需要执行的任务代码即可。</description></item><item><title>颜值测试API，微软小冰颜值，颜值API</title><link>https://blog.arae.cc/post/25740.html</link><pubDate>Wed, 17 Aug 2016 14:56:22 +0800</pubDate><guid>https://blog.arae.cc/post/25740.html</guid><description>微软小冰颜值api http://kan.msxiaobing.com/Api/ImageAnalyze/Process?service=yanzhi 在使用前我们看一下效果 {&amp;quot;msgId&amp;quot;:&amp;quot;1461905520063&amp;quot;,&amp;quot;timestamp&amp;quot;:0,&amp;quot;receiverId&amp;quot;:null,&amp;quot;content&amp;quot;:{&amp;quot;text&amp;quot;:&amp;quot;颜值7.2分，再接再厉！捯饬捯饬，说不定就是男神了呢~&amp;quot;,&amp;quot;imageUrl&amp;quot;:&amp;quot;http:\\\\/\\\\/mediaplatform.trafficmanager.cn\\\\/image\\\\/fetchimage?key=UQAfAC8ABAAAAFcAFgAGABYASgBAADgAMQBFAEQARABGAEEAMgBGADkAQgBGAEYAQwA4AEEANQAxADgAMAA4AEEANgA2ADMAMwBFADMAMAA3AEEA&amp;quot;,&amp;quot;metadata&amp;quot;:{&amp;quot;w&amp;quot;:&amp;quot;scv9isnfUnZbhOfPjNnUjOfir-3Ave_sisfqiuTo</description></item><item><title>易语言特征码定位工具源码</title><link>https://blog.arae.cc/post/25738.html</link><pubDate>Fri, 22 Jul 2016 09:28:51 +0800</pubDate><guid>https://blog.arae.cc/post/25738.html</guid><description>调用API函数实现文件的特征码定位。 链接: http://pan.baidu.com/s/1kU5mE4B 密码: mwdx</description></item><item><title>时钟事件执行时间超出时钟周期问题解释</title><link>https://blog.arae.cc/post/25737.html</link><pubDate>Thu, 21 Jul 2016 14:13:58 +0800</pubDate><guid>https://blog.arae.cc/post/25737.html</guid><description>时钟组件 作为定时器 系统会在设定时间发送 WM_TIMER 消息给消息队列，因为事件处理函数和窗口回调函数都是同线程， 在一个消息未处理完返回之前是不能处理其他事件消息的，也就是一个时钟事件函数未执行完返回之前，系统是不会发送下一个 WM_TIMER 消息到消息队列中的，所以第二个WM_TIMER消息也就是会被忽略掉。 将时钟周期设置为500 1.下面这个例子你会发现 a 和b是同步的数值是相等的就是这个道理 .局部变量 a, 整数型, 静态 .局部变量 b, 整数型, 静态 a ＝ a ＋ 1 调试输出 (“a”, a) 延时 (1000) b ＝ b ＋ 1 调试输出 (“b”, b) 2.第二个例子很有意思，你会发现程序一直在输出a ，而没有输出b，呵呵，你来猜猜是什么原因？ .局部变量 a, 整数型, 静态 .局部变量 b, 整数型, 静态 a ＝ a ＋ 1 调试输出 (“a”, a) 延迟 (1000) b ＝ b ＋ 1 调试输出 (“b”, b) 第二个例子 和第一个例子的区别是把延时（）换成了延迟（），想来看看这两个命令的作用和区别，他们的区别一个是相当于暂停当前线程向下执行，等待设定长时间后在向下执行，但并不处理事件消息； 另一个是在等待中并且处理事件消息。那么为什么会出现这样的结果呢，首先来看一下延迟（）命令 他是在等待中处理消息队列中未决的消息，那么WM_T</description></item><item><title>那些出现在电影中的程序代码</title><link>https://blog.arae.cc/post/25722.html</link><pubDate>Fri, 15 Jul 2016 13:09:06 +0800</pubDate><guid>https://blog.arae.cc/post/25722.html</guid><description>高科技无关的电影也偶尔会出现一些跟计算机相关的镜头。文本搜罗的是在各种电影中出现过的代码，它们有的是黑客脚本，有的是绝密文件，有的就是为了摆酷，文中对这些代码都有截屏，你是否能看出它们是什么语言？ 《钢铁侠》，c语言 最近我重新看了一遍《钢铁侠》，发现了一些有趣的事情。在钢铁侠的人工心脏第一次“初始化启动”期间，在那个“恐怖分子”的洞穴里，一些长长短短的C语言代码出现在那个伪造的笔记本电脑屏幕上。 屏幕上的这些代码，尽管从语法上看是少了一些重要的字符，例如分号，但的确是有效的C语言代码。写的非常规范，以至于我想弄清楚这些代码是从哪里来的。 使用谷歌一搜，我就找到了它。这段代码实际上是这样的： send[0] = 0x65; send[1] = 1; send[2] = 3; send[3] = 5; send[4] = 7; send[5] = 11; if (rcx_sendrecv(fd, send, 6, recv, 1, 50, RETRIES, use_comp) != 1) { fprintf(stderr, &amp;quot;%s: delete firmware failed\n&amp;quot;, progname); exit(1); } /* Start firmware download */ send[0] = 0x75; send[1] = (start &amp;gt;&amp;gt; 0) &amp;amp; 0xff; send[2] = (start &amp;gt;&amp;gt; 8) &amp;amp; 0xff; send[3] = (cksum &amp;gt;&amp;gt; 0) &amp;amp; 0xff; send[4] = (cksum &amp;gt;&amp;gt; 8) &amp;amp; 0xff; send[5] = 0; if (rcx_sendrecv(fd, send, 6, recv, 2, 50, RETRIES, use_comp) != 2) { fprintf(stderr, &amp;quot;%s: start firmware download failed\n&amp;quot;, progname); exit(1); } /* Transfer data */ addr = 0; index = 1; for (addr = 0, index = 1; addr &amp;lt; len; addr += size, index++) { 上面的这段代码来自一个乐高积木(LEGO，一种可编程的积木游戏)的固件下载程序，由斯坦福大学的Kekoa Proudfoot写于1998年。你可以从这里下载完成的程序</description></item><item><title>Markdown 语法整理</title><link>https://blog.arae.cc/post/25645.html</link><pubDate>Thu, 01 Jan 1970 01:00:00 +0800</pubDate><guid>https://blog.arae.cc/post/25645.html</guid><description>概述 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 标题 Code # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 ####### h7 // 错误代码 ######## h8 // 错误代码 ######### h9 // 错误代码 ########## h10 // 错误代码 Demo 注：h1最大，h6最小 分级标题 Code 注：= - 最少可以只写一个，兼容性一般 一级标题 ====================== 二级标题 --------------------- Demo TOC Code 注：根据标题生成目录，兼容性一般 [TOC] Demo 引用 Code &amp;gt; hello world! Demo hello world! Code-2 [多行式] &amp;gt; hello world! hello world! hello world! 或者 &amp;gt; hello world! hello world! hello world! Demo-2 [多行式] 结果相同 hello world! hello world! hello world! Code-3 [多层嵌套] &amp;gt; aaaaaaaaa &amp;gt;&amp;gt; bbbbbbbbb &amp;gt;&amp;gt;&amp;gt; cccccccccc Demo-3 [多层嵌套] aaaaaaaaa bbbbbbbbb cccccccccc Code-4 [多层多个元素] 注：代码前 3个</description></item></channel></rss>