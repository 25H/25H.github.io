<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>js on ARAE</title><link>https://blog.arae.cc/tags/js.html</link><description>Recent content in js on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 26 Jul 2018 20:51:45 +0800</lastBuildDate><atom:link href="https://blog.arae.cc/tags/js/index.xml" rel="self" type="application/rss+xml"/><item><title>前端上传图片并实现预览</title><link>https://blog.arae.cc/post/25793.html</link><pubDate>Thu, 26 Jul 2018 20:51:45 +0800</pubDate><guid>https://blog.arae.cc/post/25793.html</guid><description>在实际项目应用中，经常会使用到上传图片，并且可以让用户直接预览图片。对于此种做法有两种方法可以实现：一是前后台交互，后台将图片地址返回前端； 二是，使用FileReader对象——允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容；此种方法可以优化图片加载速度，减少方法一占用带宽的问题； &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;js/jquery-1.8.3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt; &amp;lt;img class=&amp;quot;img&amp;quot; id=&amp;quot;img&amp;quot; src=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt; &amp;lt;script&amp;gt; var File = document.getElementById(&#39;file&#39;); File.onchange = function(e){ var file = this.files[0]; console.log(this.files[0]) var reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = function (e) { console.log(e.target) document.getElementById(&#39;img&#39;).setAttribute(&amp;quot;src&amp;quot;,e.target.result); //e.target.result就是最后的路径地址 }; } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 关键是reader.readAsDataURL(file)这句，可以把图片转成base64格式，让img标签读取</description></item><item><title>JavaScript如何判断变量是数组还是对象</title><link>https://blog.arae.cc/post/25792.html</link><pubDate>Fri, 15 Jun 2018 15:26:38 +0800</pubDate><guid>https://blog.arae.cc/post/25792.html</guid><description>方法一 通过判断变量的类型，并且变量的length属性(除了有一种例外是arguments对象–当给函数传参时数据存储的地方) var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(typeof arr); //object console.log(typeof obj); //object console.log(arr.length); //3 console.log(obj.length); //undefined console.log(obj.name); //maomao //这里说明在对象中并没有length属性，所以是未定义。 方法二 使用toString方法将对象转换成其他类型的string，该例很好的证明了arguments对象不是数组，而是对象 var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; // console.log(arr.toString()); //&#39;2,3,4&#39; // console.log(obj.toString()); //[object Object] function sum(a,b){ // console.log(arguments); // console.log(typeof arguments); //object // console.log(arguments.length); //2 根据具体调用函数传的实参决定 // console.log(arguments.toString()); //[object Arguments] return a+b; } alert(sum(3,4)); 方法三 —&amp;gt;不可行 instanceof 指出对象是否是特定类的一个实例。 结论:instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(arr instanceof Array); //true console.log(obj instanceof Object); //true console.log(arr instanceof Object); //true // ---这里跟网上的不同，不知道是什么原因 console.log(obj instanceof Array); //false 方法四 ECMAScript 5中可以使用isArray来判断 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(Array.isArray(arr)); //true console.log(Array.isArray(obj)); //false //注意没有isObject这种方法 暂时 方法五 使用isPrototypeOf()函</description></item><item><title>使用 Async/Await 让你的代码更简洁</title><link>https://blog.arae.cc/post/25785.html</link><pubDate>Tue, 03 Apr 2018 12:42:41 +0800</pubDate><guid>https://blog.arae.cc/post/25785.html</guid><description>写在文章前 这篇文章翻译自 ASYNC/AWAIT WILL MAKE YOUR CODE SIMPLER,写于2017年八月的文章，并由某专栏提名为17年十大必读文章。在掘金上没找到这篇文章的翻译（其实没仔细找），就想试着自己翻译一下。 背景 AJAX (Asynchronous JavaScript And XML) 首先来进行一点科普。 在90年代末期， Ajax是异步JavaScript的第一个重大突破。 这个技术可以让网站在html加载之后获取和展示新的数据。对于当时大部分网站的那种需要重新下载整个个页面来展示一个部分内容的更新来说，它是革命性的创新。这项技术（在jQuery中通过捆绑成为辅助函数而闻名）在整个21世界主导了web开发，同时ajax在今天也是网站用来检索数据的主要技术，但xml却被json大规模的取代 NodeJS 当NodeJS在2009年第一次发布的时候，服务端的一个主要的关注点就是允许程序优雅的处理并发。当时大部分的服务端语言使用阻塞代码完成的这种方式来处理I/O操作，直到它结束处理I/O操作之后再继续进行之前的代码运行。取而代之，NodeJS利用事件循环体系，使用了一种类似ajax语法的工作方式:一旦非阻塞的异步操作完成之后，就可以让开发者分配的回调函数被触发。 Promises 几年之后，一个新的叫做“promis</description></item><item><title>200行JS代码实现超级简单的区块链</title><link>https://blog.arae.cc/post/25783.html</link><pubDate>Tue, 20 Mar 2018 10:35:20 +0800</pubDate><guid>https://blog.arae.cc/post/25783.html</guid><description>市面上有一个关于区块链的白皮书，有200多页，实在太长看不下去，本文通过JavaScript源码实现一个简单的区块链框架，带你入门区块链的相关知识。 区块链的基本概念非常简单：一个分布式数据库维持不断增长的有序记录列表。然而当我们谈论区块链时，我们也会谈论我们用区块链所要解决的问题，这二者通常很容易弄混淆。流行的基于区块链的项目如比特币和以太坊就是这种情况 。术语“区块链”通常与交易、智能合约或加密货币等概念紧密相关。 这使得理解区块链是一项必然要艰巨的任务。特别是源码级别的理解。在这里，我将介绍一个使用200行代码实现的超级简单的区块链——NaiveChain。 块结构 第一个逻辑步骤是确定块结构。为了让事情尽可能简单，我们只包含最必要的：索引(index)，时间戳(timestamp)，数据(data)，哈希(hash)和上一个哈希(previousHash)。 class Block { constructor(index, previousHash, timestamp, data, hash) { this.index = index; this.previousHash = previousHash.toString(); this.timestamp = timestamp; this.data = data; this.hash = hash.toString(); } } 块哈希 该块需要被哈希运算以保持数据的完整性。SHA-256被用来做哈希算法处理块的内容。需要注意的是这个哈希与“挖矿” 无关，因为没有解决工作量证明(Proof Of Work )的问题。 var calculateHash = (index, previousHash,</description></item><item><title>HEXO.NexT 表情测试 - b1</title><link>https://blog.arae.cc/post/25778.html</link><pubDate>Wed, 07 Mar 2018 18:55:41 +0800</pubDate><guid>https://blog.arae.cc/post/25778.html</guid><description>这破东西之前弄过两三次，每次都比这个好@pp{阴险}，最后忘记啥毛病都删了。。 调用代码大概就是@pp/{滑稽}(就当/不存在)中间那个pp方便以后添加其他表情，虽说有个别地方写死了@pp{你懂的}。。 @pp{滑稽}@pp{滑稽}@pp{滑稽}这个魔性的表情我都眼馋很久了@pp{滑稽}@pp{滑稽}@pp{滑稽} @pp{呵呵}@pp{哈哈}@pp{吐舌}@pp{太开心}@pp{笑眼}@pp{花心}@pp{小乖}@pp{乖}@pp{捂嘴笑}@pp{滑稽}@pp{你懂的}@pp{不高兴}@pp{怒}@pp{汗}@pp{黑线}@pp{泪}@pp{真棒}@pp{喷}@pp{惊哭}@pp{阴险}@pp{鄙视}@pp{酷}@pp{啊}@pp{狂汗}@pp{what}@pp{疑问}@pp{酸爽}@pp{呀咩爹}@pp{委屈}@pp{惊讶}@pp{睡觉}@pp{笑尿}@pp{挖鼻}@pp{吐}@pp{犀利}@pp{小红脸}@pp{懒得理}@pp{勉强}@pp{爱心}@pp{心碎}@pp{玫瑰}@pp{礼物}@pp{彩虹}@pp{太阳}@pp{星星月亮}@pp{钱币}@pp{茶杯}@pp{蛋糕}@pp{大</description></item><item><title>jquery判断图片或者背景图片加载完毕</title><link>https://blog.arae.cc/post/25771.html</link><pubDate>Thu, 15 Feb 2018 13:37:24 +0800</pubDate><guid>https://blog.arae.cc/post/25771.html</guid><description>前端开发制作中有需要需要等到页面中的图片加载完毕后才执行某些事件，而使用jquery的load事件只是dom执行完毕，图片未必加载完成，如果要判断图片加载完毕，需要在图片标签上判断。 使用JavaScript判断图片加载完毕，如果图片在页面中的某个img标签中的话，可以用下面这个 $(&#39;img&#39;).on(&#39;load&#39;, function() { alert(&#39;new image loaded: &#39; + this.src); }); 原生js imgNode.onload = () =&amp;gt; { alert(&#39;new image loaded: &#39; + this.src); }; （1）、单张图片（图片在文档中） // HTML &amp;lt;img id=&#39;pic&#39; src=&amp;quot;../03.png&amp;quot;&amp;gt; //js $(document).ready(function(){ //jquery $(&#39;#pic&#39;).load(function(){ // 加载完成 }); //原生 onload var pic = document.getElementById(&#39;pic&#39;) pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; }) 注： 1、IE8及以下版本不支持onload事件，但支持onreadystatechange事件； 2、readyState是onreadystatechange事件的一个状态，值为loaded或complete的时候，表示已经加载完毕。 3、如果引入jquery库可以考虑直接使用jquery的load事件来解决兼容问题。 （2）、单张图片（图片动态生成） //js var pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; //jquery $(&#39;&amp;lt;img/&amp;gt;&#39;).attr(&#39;src&#39;, &#39;../03.png&#39;).on(&#39;load&#39;, function() { $(this).remove(); // 防止内存泄露 //图片加载完毕 }); （3）、单张图片（结合ES6 Promise） //js new Promise((resolve, reject)=&amp;gt;{ let pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = function(){ // 加载完成 resolve(pic) } }).then((pic)=&amp;gt;{ //code }) （4）、多张图片 var img = [], flag = 0,</description></item></channel></rss>