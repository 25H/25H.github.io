<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>代码 on ARAE</title><link>https://arae.cc/tags/%E4%BB%A3%E7%A0%81.html</link><description>Recent content in 代码 on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 26 Jul 2018 20:51:45 +0800</lastBuildDate><atom:link href="https://arae.cc/tags/%E4%BB%A3%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>前端上传图片并实现预览</title><link>https://arae.cc/post/25793.html</link><pubDate>Thu, 26 Jul 2018 20:51:45 +0800</pubDate><guid>https://arae.cc/post/25793.html</guid><description>在实际项目应用中，经常会使用到上传图片，并且可以让用户直接预览图片。对于此种做法有两种方法可以实现：一是前后台交互，后台将图片地址返回前端； 二是，使用FileReader对象——允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容；此种方法可以优化图片加载速度，减少方法一占用带宽的问题； &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;js/jquery-1.8.3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt; &amp;lt;img class=&amp;quot;img&amp;quot; id=&amp;quot;img&amp;quot; src=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt; &amp;lt;script&amp;gt; var File = document.getElementById(&#39;file&#39;); File.onchange = function(e){ var file = this.files[0]; console.log(this.files[0]) var reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = function (e) { console.log(e.target) document.getElementById(&#39;img&#39;).setAttribute(&amp;quot;src&amp;quot;,e.target.result); //e.target.result就是最后的路径地址 }; } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 关键是reader.readAsDataURL(file)这句，可以把图片转成base64格式，让img标签读取</description></item><item><title>JavaScript如何判断变量是数组还是对象</title><link>https://arae.cc/post/25792.html</link><pubDate>Fri, 15 Jun 2018 15:26:38 +0800</pubDate><guid>https://arae.cc/post/25792.html</guid><description>方法一 通过判断变量的类型，并且变量的length属性(除了有一种例外是arguments对象–当给函数传参时数据存储的地方) var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(typeof arr); //object console.log(typeof obj); //object console.log(arr.length); //3 console.log(obj.length); //undefined console.log(obj.name); //maomao //这里说明在对象中并没有length属性，所以是未定义。 方法二 使用toString方法将对象转换成其他类型的string，该例很好的证明了arguments对象不是数组，而是对象 var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; // console.log(arr.toString()); //&#39;2,3,4&#39; // console.log(obj.toString()); //[object Object] function sum(a,b){ // console.log(arguments); // console.log(typeof arguments); //object // console.log(arguments.length); //2 根据具体调用函数传的实参决定 // console.log(arguments.toString()); //[object Arguments] return a+b; } alert(sum(3,4)); 方法三 —&amp;gt;不可行 instanceof 指出对象是否是特定类的一个实例。 结论:instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(arr instanceof Array); //true console.log(obj instanceof Object); //true console.log(arr instanceof Object); //true // ---这里跟网上的不同，不知道是什么原因 console.log(obj instanceof Array); //false 方法四 ECMAScript 5中可以使用isArray来判断 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(Array.isArray(arr)); //true console.log(Array.isArray(obj)); //false //注意没有isObject这种方法 暂时 方法五 使用isPrototypeOf()函</description></item><item><title>H5 video 视频标签属性详解</title><link>https://arae.cc/post/25788.html</link><pubDate>Sat, 05 May 2018 17:46:18 +0800</pubDate><guid>https://arae.cc/post/25788.html</guid><description>前言 HTML5标签video在PC上显示很简单，就一个标签加资源，很少需要关心其它属性。但放到移动设备上，video的标准，Android和ios有很多区别，另外还有很多各家浏览器特定的属性. video属性 &amp;lt;video id=&amp;quot;video&amp;quot; src=&amp;quot;video.mp4&amp;quot; controls = &amp;quot;true&amp;quot; poster=&amp;quot;images.jpg&amp;quot; /* 视频封面 */ preload=&amp;quot;auto&amp;quot; webkit-playsinline=&amp;quot;true&amp;quot; /* 这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放 */ playsinline=&amp;quot;true&amp;quot; /* IOS微信浏览器支持小窗内播放 */ x-webkit-airplay=&amp;quot;allow&amp;quot; x5-video-player-type=&amp;quot;h5&amp;quot; /* 启用H5播放器,是wechat安卓版特性 */ x5-video-player-fullscreen=&amp;quot;true&amp;quot; /* 全屏设置，设置为 true 是防止横屏 */ x5-video-orientation=&amp;quot;portraint&amp;quot; /* 播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏 */ style=&amp;quot;object-fit:fill&amp;quot;&amp;gt; &amp;lt;/video&amp;gt; src: 视频的地址 controls: 加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 poster: 属性规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。如果未设置该属性，则使用视频的第一帧来代替。 preload: 属性规定在页面加载后载入视频。 webkit-playsinline和playsinline: 视频播放时局域播放，不脱离文档流 。但是这个属性比较特别， 需要嵌入网页的APP比如WeChat中UIwebview 的allowsInlineMediaPlayback = YES webview.allowsInlineMediaPlayback</description></item><item><title>200行JS代码实现超级简单的区块链</title><link>https://arae.cc/post/25783.html</link><pubDate>Tue, 20 Mar 2018 10:35:20 +0800</pubDate><guid>https://arae.cc/post/25783.html</guid><description>市面上有一个关于区块链的白皮书，有200多页，实在太长看不下去，本文通过JavaScript源码实现一个简单的区块链框架，带你入门区块链的相关知识。 区块链的基本概念非常简单：一个分布式数据库维持不断增长的有序记录列表。然而当我们谈论区块链时，我们也会谈论我们用区块链所要解决的问题，这二者通常很容易弄混淆。流行的基于区块链的项目如比特币和以太坊就是这种情况 。术语“区块链”通常与交易、智能合约或加密货币等概念紧密相关。 这使得理解区块链是一项必然要艰巨的任务。特别是源码级别的理解。在这里，我将介绍一个使用200行代码实现的超级简单的区块链——NaiveChain。 块结构 第一个逻辑步骤是确定块结构。为了让事情尽可能简单，我们只包含最必要的：索引(index)，时间戳(timestamp)，数据(data)，哈希(hash)和上一个哈希(previousHash)。 class Block { constructor(index, previousHash, timestamp, data, hash) { this.index = index; this.previousHash = previousHash.toString(); this.timestamp = timestamp; this.data = data; this.hash = hash.toString(); } } 块哈希 该块需要被哈希运算以保持数据的完整性。SHA-256被用来做哈希算法处理块的内容。需要注意的是这个哈希与“挖矿” 无关，因为没有解决工作量证明(Proof Of Work )的问题。 var calculateHash = (index, previousHash,</description></item><item><title>jquery判断图片或者背景图片加载完毕</title><link>https://arae.cc/post/25771.html</link><pubDate>Thu, 15 Feb 2018 13:37:24 +0800</pubDate><guid>https://arae.cc/post/25771.html</guid><description>前端开发制作中有需要需要等到页面中的图片加载完毕后才执行某些事件，而使用jquery的load事件只是dom执行完毕，图片未必加载完成，如果要判断图片加载完毕，需要在图片标签上判断。 使用JavaScript判断图片加载完毕，如果图片在页面中的某个img标签中的话，可以用下面这个 $(&#39;img&#39;).on(&#39;load&#39;, function() { alert(&#39;new image loaded: &#39; + this.src); }); 原生js imgNode.onload = () =&amp;gt; { alert(&#39;new image loaded: &#39; + this.src); }; （1）、单张图片（图片在文档中） // HTML &amp;lt;img id=&#39;pic&#39; src=&amp;quot;../03.png&amp;quot;&amp;gt; //js $(document).ready(function(){ //jquery $(&#39;#pic&#39;).load(function(){ // 加载完成 }); //原生 onload var pic = document.getElementById(&#39;pic&#39;) pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; }) 注： 1、IE8及以下版本不支持onload事件，但支持onreadystatechange事件； 2、readyState是onreadystatechange事件的一个状态，值为loaded或complete的时候，表示已经加载完毕。 3、如果引入jquery库可以考虑直接使用jquery的load事件来解决兼容问题。 （2）、单张图片（图片动态生成） //js var pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; //jquery $(&#39;&amp;lt;img/&amp;gt;&#39;).attr(&#39;src&#39;, &#39;../03.png&#39;).on(&#39;load&#39;, function() { $(this).remove(); // 防止内存泄露 //图片加载完毕 }); （3）、单张图片（结合ES6 Promise） //js new Promise((resolve, reject)=&amp;gt;{ let pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = function(){ // 加载完成 resolve(pic) } }).then((pic)=&amp;gt;{ //code }) （4）、多张图片 var img = [], flag = 0,</description></item><item><title>程序猿专用代码注释:佛祖保佑，永无BUG</title><link>https://arae.cc/post/25736.html</link><pubDate>Wed, 20 Jul 2016 02:17:56 +0800</pubDate><guid>https://arae.cc/post/25736.html</guid><description>逛论坛发现这个,实在是高上大啊 // _ooOoo_ // o8888888o // 88&amp;quot; . &amp;quot;88 // (| -_- |) // O\ = /O // ____/`---&#39;\____ // . &#39; \\| |// `. // / \\||| : |||// \ // / _||||| -:- |||||- \ // | | \\\ - /// | | // | \_| &#39;&#39;\---/&#39;&#39; | | // \ .-\__ `-` ___/-. / // ___`. .&#39; /--.--\ `. . __ // .&amp;quot;&amp;quot; &#39;&amp;lt; `.___\_&amp;lt;|&amp;gt;_/___.&#39; &amp;gt;&#39;&amp;quot;&amp;quot;. // | | : `- \`.;`\ _ /`;.`/ - ` : | | // \ \ `-. \_ __\ /__ _/ .-` / / // ======`-.____`-.___\_____/___.-`____.-&#39;====== // `=---=&#39; // // ............................................. // 佛祖保佑 永无BUG // 佛曰: // 写字楼里写字间，写字间里程序员； // 程序人员写程序，又拿程序换酒钱。 // 酒醒只在网上坐，酒醉还来网下眠； // 酒醉酒醒日复日，网上网下年复年。 // 但愿老死电脑间，不愿鞠躬老板前； // 奔驰宝马贵者趣，公交自行程序员。 // 别人笑我忒疯癫，我笑自己命太贱； // 不见满街漂亮妹，哪个归得程序员？</description></item><item><title>10个最“优秀”的代码注释</title><link>https://arae.cc/post/25729.html</link><pubDate>Fri, 15 Jul 2016 13:48:46 +0800</pubDate><guid>https://arae.cc/post/25729.html</guid><description>下面是stackoverflow网站上网友针对你看到过的最好的代码注释是什么样的？这个问题给出的回答的前10条： // 亲爱的维护者： // 如果你尝试了对这段程序进行‘优化’， // 并认识到这种企图是大错特错，请增加 // 下面这个计数器的个数，用来对后来人进行警告： // 浪费在这里的总时间 = 39h /** * 致终于来到这里的勇敢的人： 你是被上帝选中的人，英勇的、不辞劳苦的、不眠不修的来修改 我们这最棘手的代码的编程骑士。你，我们的救世主，人中之龙， 我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己。 永远不要哭啼，永远不要说再见。永远不要说谎来伤害自己。 */ Exception up = new Exception(&amp;quot;Something is really wrong.&amp;quot;); throw up; // 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 // 一些修改2 - 2007/5/22 我临时的犯傻 #define TRUE FALSE //逗一逗调试程序的傻瓜们 if (/*you*/ $_GET[&#39;action&#39;]) { //celebrate(恭喜) // 如果这段代码好用，那它是Paul DiLascia写的。 //如果不好用，我不知道是谁写的。 //写这段代码的时候，只有上帝和我知道它是干嘛的 //现在，只有上帝知道 // 晕了，以后再修改 // 神奇。勿动。 你有没有更绝的？</description></item><item><title>为什么谷歌要执行严格的代码编写规范</title><link>https://arae.cc/post/25725.html</link><pubDate>Fri, 15 Jul 2016 13:23:10 +0800</pubDate><guid>https://arae.cc/post/25725.html</guid><description>我们在谷歌所做事情中另外一个让我感到异常有效、有用的制度是严格的编码规范。 在到Google工作之前，我一直认为编码规范没有什么用处。我坚信这些规范都是官僚制度下产生的浪费大家的编程时间、影响人们开发效率的东西。 我是大错特错了。 在谷歌，我可以查看任何的代码，进入所有谷歌的代码库，我有权查看它们。事实上，这种权限是很少人能拥有的。但是，让我感到惊讶的却是，如此多的编码规范—缩进，命名，文件结构，注释风格—这一切让我出乎意料的轻松的阅读任意一段代码，并轻易的看懂它们。这让我震惊—因为我以为这些规范是微不足道的东西。它们不可能有这么大的作用—但它们却起到了这么大的作用。当你发现只通过看程序的基本语法结构就能读懂一段代码，这种时间上的节省不能不让人震撼！ 反对编码规范的人很多，下面是一些常见的理由，对于这些理由，我以前是深信不疑。 这是浪费时间！ 我是一个优秀的程序员，我不愿意浪费时间干这些愚蠢的事。我的技术很好，我可以写出清晰的、易于理解的代码。为什么我要浪费时间遵守这些愚蠢的规范？答案是：统一是有价值的。就像我前面说的—你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差</description></item><item><title>那些出现在电影中的程序代码</title><link>https://arae.cc/post/25722.html</link><pubDate>Fri, 15 Jul 2016 13:09:06 +0800</pubDate><guid>https://arae.cc/post/25722.html</guid><description>高科技无关的电影也偶尔会出现一些跟计算机相关的镜头。文本搜罗的是在各种电影中出现过的代码，它们有的是黑客脚本，有的是绝密文件，有的就是为了摆酷，文中对这些代码都有截屏，你是否能看出它们是什么语言？ 《钢铁侠》，c语言 最近我重新看了一遍《钢铁侠》，发现了一些有趣的事情。在钢铁侠的人工心脏第一次“初始化启动”期间，在那个“恐怖分子”的洞穴里，一些长长短短的C语言代码出现在那个伪造的笔记本电脑屏幕上。 屏幕上的这些代码，尽管从语法上看是少了一些重要的字符，例如分号，但的确是有效的C语言代码。写的非常规范，以至于我想弄清楚这些代码是从哪里来的。 使用谷歌一搜，我就找到了它。这段代码实际上是这样的： send[0] = 0x65; send[1] = 1; send[2] = 3; send[3] = 5; send[4] = 7; send[5] = 11; if (rcx_sendrecv(fd, send, 6, recv, 1, 50, RETRIES, use_comp) != 1) { fprintf(stderr, &amp;quot;%s: delete firmware failed\n&amp;quot;, progname); exit(1); } /* Start firmware download */ send[0] = 0x75; send[1] = (start &amp;gt;&amp;gt; 0) &amp;amp; 0xff; send[2] = (start &amp;gt;&amp;gt; 8) &amp;amp; 0xff; send[3] = (cksum &amp;gt;&amp;gt; 0) &amp;amp; 0xff; send[4] = (cksum &amp;gt;&amp;gt; 8) &amp;amp; 0xff; send[5] = 0; if (rcx_sendrecv(fd, send, 6, recv, 2, 50, RETRIES, use_comp) != 2) { fprintf(stderr, &amp;quot;%s: start firmware download failed\n&amp;quot;, progname); exit(1); } /* Transfer data */ addr = 0; index = 1; for (addr = 0, index = 1; addr &amp;lt; len; addr += size, index++) { 上面的这段代码来自一个乐高积木(LEGO，一种可编程的积木游戏)的固件下载程序，由斯坦福大学的Kekoa Proudfoot写于1998年。你可以从这里下载完成的程序</description></item><item><title>梦代码编辑框支持库 （2.1#0版）</title><link>https://arae.cc/post/25680.html</link><pubDate>Sat, 25 Jun 2016 14:39:15 +0800</pubDate><guid>https://arae.cc/post/25680.html</guid><description>将 mcse.fne 放到易语言目录的 lib目录中 将 mcse_static.lib 放到易语言目录的 static_lib目录中 感谢mudxni、独孤无情、可爱小浅反馈BUG。 声明：本支持库是完整的移植了火花代码编辑框，在此感谢大色秘密、小刀！ 2.1更新说明： &amp;gt;1.修复了TAB键跳到其它窗口组件。 &amp;gt;2.修复了窗口属性里面的光标颜色和光标闪烁间隔错位。 &amp;gt;3.对代码进行了优化减少了体积。 链接: http://pan.baidu.com/s/1kVfbb0b 密码: z14u</description></item><item><title>如何编写高质量的易语言代码？</title><link>https://arae.cc/post/25654.html</link><pubDate>Sat, 25 Jun 2016 14:37:51 +0800</pubDate><guid>https://arae.cc/post/25654.html</guid><description>什么是一个高效的软件？一个高效的软件不仅应该比实现同样功能的软件运行得更快，还应该消耗更少的系统资源。程序的时间效率是指运行速度，空间效率是指程序占用内存或者外存的状况。另外程序的效率我们也可以分为全局效率和局部效率。全局效率是指站在整个系统的角度上考虑的效率，局部效率是指站在模块或函数角度上考虑的效率。 使用整数和长整数 提高代码运行速度最简单的方法莫过于使用正确的数据类型了。也许你不相信，但是 正确地选择数据类型可以大幅度提升代码的性能。在大多数情况下，程序员可以将短整数型、小数型和双精度小数型的变量替换为整数（Integer）或长整数（Long）类型的变量，因为易语言处理整数和长整数的能力远远高于处理其它几种数据类型。 在大多数情况下，程序员选择使用小数型或双精度小数型的原因是因为它们能够保存小数。但是小数也可以保存在整数类型的变量中。例如程序中约定有三位小数，那么只需要将保存在整数型变量中的数值除以1000就可以得到结果。根据我的经验，使用整数和长整数替代短整数型、小数型和双精度小数型后，代码的运行速度可以提高将近10倍。 但是我们也不要老是强调使用使用整数和长整数，因为在程序中数据类型</description></item></channel></rss>