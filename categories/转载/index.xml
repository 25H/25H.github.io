<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>转载 on ARAE</title><link>https://arae.cc/categories/%E8%BD%AC%E8%BD%BD.html</link><description>Recent content in 转载 on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 15 Jun 2018 15:26:38 +0800</lastBuildDate><atom:link href="https://arae.cc/categories/%E8%BD%AC%E8%BD%BD/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript如何判断变量是数组还是对象</title><link>https://arae.cc/post/25792.html</link><pubDate>Fri, 15 Jun 2018 15:26:38 +0800</pubDate><guid>https://arae.cc/post/25792.html</guid><description>方法一 通过判断变量的类型，并且变量的length属性(除了有一种例外是arguments对象–当给函数传参时数据存储的地方) var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(typeof arr); //object console.log(typeof obj); //object console.log(arr.length); //3 console.log(obj.length); //undefined console.log(obj.name); //maomao //这里说明在对象中并没有length属性，所以是未定义。 方法二 使用toString方法将对象转换成其他类型的string，该例很好的证明了arguments对象不是数组，而是对象 var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; // console.log(arr.toString()); //&#39;2,3,4&#39; // console.log(obj.toString()); //[object Object] function sum(a,b){ // console.log(arguments); // console.log(typeof arguments); //object // console.log(arguments.length); //2 根据具体调用函数传的实参决定 // console.log(arguments.toString()); //[object Arguments] return a+b; } alert(sum(3,4)); 方法三 —&amp;gt;不可行 instanceof 指出对象是否是特定类的一个实例。 结论:instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(arr instanceof Array); //true console.log(obj instanceof Object); //true console.log(arr instanceof Object); //true // ---这里跟网上的不同，不知道是什么原因 console.log(obj instanceof Array); //false 方法四 ECMAScript 5中可以使用isArray来判断 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(Array.isArray(arr)); //true console.log(Array.isArray(obj)); //false //注意没有isObject这种方法 暂时 方法五 使用isPrototypeOf()函</description></item><item><title>12 个免费图片快速优化和压缩工具</title><link>https://arae.cc/post/25790.html</link><pubDate>Sun, 27 May 2018 08:56:28 +0800</pubDate><guid>https://arae.cc/post/25790.html</guid><description>图像压缩工具允许轻松的进行压缩，编辑和调整图片大小。这些工具支持多种图像格式，如JPEG，PNG，GIF，可以重新大小根据您的需要他们，让您的网站和 Web 应用程序的拥有更快的载入速度。 在这里，编制了12个最佳的图片压缩工具，所有这些都将帮助你压缩你的网站上的图像，节省带宽和提高网站的性能。 1. JPEGMini JPEGmini是一项正在申请专利的照片再压缩技术，可显着缩小照片尺寸而不影响其感知质量。 该技术适用于基准JPEG领域，可生成与任何浏览器，照片软件或支持标准JPEG格式的设备完全兼容的文件。 2. Shrink O’ Matic Shrink O’ Matic是一款AIR应用程序，可轻松（批量）调整图像大小（缩小）。 它处理JPG，GIF和PNG。 只需拖放图像，就可以随意调整大小！ 选项允许您选择输出大小，旋转（支持EXIF数据），名称和位置，格式和水印。 3. Riot Radical Image Optimization Tool（简称RIOT）是一款免费的图像优化工具，可让您在保持最小文件大小的同时在视觉上调整压缩参数。 它使用并排（双视图）或单视图界面来实时比较原始图像和优化图像，并即时查看生成的文件大小。 它轻巧，快速且简单易用，但对于高级用户而言功能强大。 您将能够控制压缩，颜色数量，元数据设置等等，</description></item><item><title>H5 video 视频标签属性详解</title><link>https://arae.cc/post/25788.html</link><pubDate>Sat, 05 May 2018 17:46:18 +0800</pubDate><guid>https://arae.cc/post/25788.html</guid><description>前言 HTML5标签video在PC上显示很简单，就一个标签加资源，很少需要关心其它属性。但放到移动设备上，video的标准，Android和ios有很多区别，另外还有很多各家浏览器特定的属性. video属性 &amp;lt;video id=&amp;quot;video&amp;quot; src=&amp;quot;video.mp4&amp;quot; controls = &amp;quot;true&amp;quot; poster=&amp;quot;images.jpg&amp;quot; /* 视频封面 */ preload=&amp;quot;auto&amp;quot; webkit-playsinline=&amp;quot;true&amp;quot; /* 这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放 */ playsinline=&amp;quot;true&amp;quot; /* IOS微信浏览器支持小窗内播放 */ x-webkit-airplay=&amp;quot;allow&amp;quot; x5-video-player-type=&amp;quot;h5&amp;quot; /* 启用H5播放器,是wechat安卓版特性 */ x5-video-player-fullscreen=&amp;quot;true&amp;quot; /* 全屏设置，设置为 true 是防止横屏 */ x5-video-orientation=&amp;quot;portraint&amp;quot; /* 播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏 */ style=&amp;quot;object-fit:fill&amp;quot;&amp;gt; &amp;lt;/video&amp;gt; src: 视频的地址 controls: 加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 poster: 属性规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。如果未设置该属性，则使用视频的第一帧来代替。 preload: 属性规定在页面加载后载入视频。 webkit-playsinline和playsinline: 视频播放时局域播放，不脱离文档流 。但是这个属性比较特别， 需要嵌入网页的APP比如WeChat中UIwebview 的allowsInlineMediaPlayback = YES webview.allowsInlineMediaPlayback</description></item><item><title>使用 Async/Await 让你的代码更简洁</title><link>https://arae.cc/post/25785.html</link><pubDate>Tue, 03 Apr 2018 12:42:41 +0800</pubDate><guid>https://arae.cc/post/25785.html</guid><description>写在文章前 这篇文章翻译自 ASYNC/AWAIT WILL MAKE YOUR CODE SIMPLER,写于2017年八月的文章，并由某专栏提名为17年十大必读文章。在掘金上没找到这篇文章的翻译（其实没仔细找），就想试着自己翻译一下。 背景 AJAX (Asynchronous JavaScript And XML) 首先来进行一点科普。 在90年代末期， Ajax是异步JavaScript的第一个重大突破。 这个技术可以让网站在html加载之后获取和展示新的数据。对于当时大部分网站的那种需要重新下载整个个页面来展示一个部分内容的更新来说，它是革命性的创新。这项技术（在jQuery中通过捆绑成为辅助函数而闻名）在整个21世界主导了web开发，同时ajax在今天也是网站用来检索数据的主要技术，但xml却被json大规模的取代 NodeJS 当NodeJS在2009年第一次发布的时候，服务端的一个主要的关注点就是允许程序优雅的处理并发。当时大部分的服务端语言使用阻塞代码完成的这种方式来处理I/O操作，直到它结束处理I/O操作之后再继续进行之前的代码运行。取而代之，NodeJS利用事件循环体系，使用了一种类似ajax语法的工作方式:一旦非阻塞的异步操作完成之后，就可以让开发者分配的回调函数被触发。 Promises 几年之后，一个新的叫做“promis</description></item><item><title>200行JS代码实现超级简单的区块链</title><link>https://arae.cc/post/25783.html</link><pubDate>Tue, 20 Mar 2018 10:35:20 +0800</pubDate><guid>https://arae.cc/post/25783.html</guid><description>市面上有一个关于区块链的白皮书，有200多页，实在太长看不下去，本文通过JavaScript源码实现一个简单的区块链框架，带你入门区块链的相关知识。 区块链的基本概念非常简单：一个分布式数据库维持不断增长的有序记录列表。然而当我们谈论区块链时，我们也会谈论我们用区块链所要解决的问题，这二者通常很容易弄混淆。流行的基于区块链的项目如比特币和以太坊就是这种情况 。术语“区块链”通常与交易、智能合约或加密货币等概念紧密相关。 这使得理解区块链是一项必然要艰巨的任务。特别是源码级别的理解。在这里，我将介绍一个使用200行代码实现的超级简单的区块链——NaiveChain。 块结构 第一个逻辑步骤是确定块结构。为了让事情尽可能简单，我们只包含最必要的：索引(index)，时间戳(timestamp)，数据(data)，哈希(hash)和上一个哈希(previousHash)。 class Block { constructor(index, previousHash, timestamp, data, hash) { this.index = index; this.previousHash = previousHash.toString(); this.timestamp = timestamp; this.data = data; this.hash = hash.toString(); } } 块哈希 该块需要被哈希运算以保持数据的完整性。SHA-256被用来做哈希算法处理块的内容。需要注意的是这个哈希与“挖矿” 无关，因为没有解决工作量证明(Proof Of Work )的问题。 var calculateHash = (index, previousHash,</description></item><item><title>jquery判断图片或者背景图片加载完毕</title><link>https://arae.cc/post/25771.html</link><pubDate>Thu, 15 Feb 2018 13:37:24 +0800</pubDate><guid>https://arae.cc/post/25771.html</guid><description>前端开发制作中有需要需要等到页面中的图片加载完毕后才执行某些事件，而使用jquery的load事件只是dom执行完毕，图片未必加载完成，如果要判断图片加载完毕，需要在图片标签上判断。 使用JavaScript判断图片加载完毕，如果图片在页面中的某个img标签中的话，可以用下面这个 $(&#39;img&#39;).on(&#39;load&#39;, function() { alert(&#39;new image loaded: &#39; + this.src); }); 原生js imgNode.onload = () =&amp;gt; { alert(&#39;new image loaded: &#39; + this.src); }; （1）、单张图片（图片在文档中） // HTML &amp;lt;img id=&#39;pic&#39; src=&amp;quot;../03.png&amp;quot;&amp;gt; //js $(document).ready(function(){ //jquery $(&#39;#pic&#39;).load(function(){ // 加载完成 }); //原生 onload var pic = document.getElementById(&#39;pic&#39;) pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; }) 注： 1、IE8及以下版本不支持onload事件，但支持onreadystatechange事件； 2、readyState是onreadystatechange事件的一个状态，值为loaded或complete的时候，表示已经加载完毕。 3、如果引入jquery库可以考虑直接使用jquery的load事件来解决兼容问题。 （2）、单张图片（图片动态生成） //js var pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; //jquery $(&#39;&amp;lt;img/&amp;gt;&#39;).attr(&#39;src&#39;, &#39;../03.png&#39;).on(&#39;load&#39;, function() { $(this).remove(); // 防止内存泄露 //图片加载完毕 }); （3）、单张图片（结合ES6 Promise） //js new Promise((resolve, reject)=&amp;gt;{ let pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = function(){ // 加载完成 resolve(pic) } }).then((pic)=&amp;gt;{ //code }) （4）、多张图片 var img = [], flag = 0,</description></item><item><title>PHP导出Excel、CSV文件，并解决显示不正常等问题</title><link>https://arae.cc/post/25765.html</link><pubDate>Mon, 09 Oct 2017 19:23:11 +0800</pubDate><guid>https://arae.cc/post/25765.html</guid><description>最近一直在折腾PHP，无意间想实现个导出表格的功能。 不料用了header声明后的表格中文是乱码的，后来通过转字符、添加字母符号、style等方法才得以让excel导出后显示正常了。 为了解决部分MySQL环境设置问题，又添加了一个CSV的导出方法。 导出Excel代码 header(&amp;quot;Content-type:application/vnd.ms-excel;charset=UTF-8&amp;quot;); header(&amp;quot;Content-Disposition:attachment;filename=xxxxx.xls&amp;quot;); //输出标题 echo &amp;quot;&amp;lt;table border=&#39;1&#39;&amp;gt;&amp;quot;; echo &amp;quot;&amp;lt;th&amp;gt;&amp;quot;.mb_convert_encoding($str, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;).&amp;quot;&amp;lt;/th&amp;gt;&amp;quot;; echo &amp;quot;&amp;lt;th&amp;gt;&amp;quot;.mb_convert_encoding($str, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;).&amp;quot;&amp;lt;/th&amp;gt;&amp;quot;; echo &amp;quot;&amp;lt;th&amp;gt;&amp;quot;.mb_convert_encoding($str, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;).&amp;quot;&amp;lt;/th&amp;gt;&amp;quot;; #.... //输出每行的内容 for ($i=0; $i &amp;lt; count($Data); $i++) { echo &amp;quot;&amp;lt;tr&amp;gt;&amp;quot;; for ($n=0; $n &amp;lt; count($Data[$i]); $n++) { //添加 style=&#39;vnd.ms-excel.numberformat:@&#39; 将内容作为字符串识别 echo &amp;quot;&amp;lt;td style=&#39;vnd.ms-excel.numberformat:@&#39;&amp;gt;&amp;quot;; echo mb_convert_encoding($Data[$i][$n],&amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;); echo &amp;quot;&amp;lt;/td&amp;gt;&amp;quot;; } echo &amp;quot;&amp;lt;/tr&amp;gt;&amp;quot;; } echo &amp;quot;&amp;lt;/table&amp;gt;&amp;quot;; 导出CSV代码 /** * 导出CSV文件 * @param string $fileName 文件名字 * @param string|array $data 导出数据，csv格式的字符串|数值数组 * @param string $to_encoding 目标转换编码 * @param string $from_encoding 当前编码 */ function exportCSV($fileName = &#39;&#39;, $data = &#39;&#39;, $to_encoding = &#39;gb2312&#39;, $from_encoding = &#39;utf-8&#39;) { $fileName = empty($fileName) ? date(&#39;YmdHis&#39;) : $fileName; // 文件标签 Header(&amp;quot;Content-type: application/octet-stream&amp;quot;); header(&amp;quot;Content-type: application/vnd.ms-excel; charset=$from_encoding&amp;quot;); Header(&amp;quot;Content-Disposition: attachment; filename=$fileName.csv&amp;quot;); $str = &#39;&#39;; if($data) { if(is_array($data)) { foreach ($data as $v) { if(is_array($v)) { foreach ($v as $vo) { $str .= (is_numeric($vo) ? &amp;quot;&#39;&amp;quot;.$vo : $vo.&amp;quot;&amp;quot;).&amp;quot;,&amp;quot;; } $str = trim($str, &amp;quot;,&amp;quot;).&amp;quot;\r\n&amp;quot;; } else { $str .= (is_numeric($v) ? &amp;quot;&#39;&amp;quot;.$v : $v).&amp;quot;,&amp;quot;; } } $str = trim($str, &amp;quot;,&amp;quot;).&amp;quot;\r\n&amp;quot;; } else { $str = $data; } } echo mb_convert_encoding($str, &amp;quot;gb2312&amp;quot;, &amp;quot;utf-8&amp;quot;); exit; } exportCSV($fileName=$str,$data = $Data); ?&amp;gt;</description></item><item><title>8行代码在Python3中实现多核并行执行</title><link>https://arae.cc/post/25767.html</link><pubDate>Thu, 21 Sep 2017 16:41:38 +0800</pubDate><guid>https://arae.cc/post/25767.html</guid><description>python作为一个简单的脚本语言在工作中会经常用到，但奈何执行大量重复性任务时单线程效率低下，这时可以通过多线程并行执行大大提高代码执行效率。 Python3多核并行执行完整示例：（可以复制粘贴到IDLE运行一下） import threading, time from queue import Queue def basic_worker(queue): while True: item = queue.get() print(str(item)+&amp;quot;\r\n&amp;quot;) queue.task_done() def basic(): ts = time.time() queue = Queue() for i in range(3): t = threading.Thread(target=basic_worker,args=(queue,)) t.daemon = True t.start() for item in range(100): #创建任务队例 queue.put(item) queue.join() print(&#39;Took {}&#39;.format(time.time() - ts)) #执行结束，输出执行时长 if __name__ == &#39;__main__&#39;: basic() 并行计算主要是通过下面这8行代码来实现的： queue = Queue() #初始化一个队例 for i in range(3): t = threading.Thread(target=basic_worker,args=(queue,)) t.daemon = True t.start() for item in range(100): #创建任务队例 queue.put(item) queue.join() 上面的代码创建了3个线程（具体线程数量可根据任务复杂度及机器配置进行调整），并通过queue.put(item) 写入任务队例及所需参数，最后通过queue.join() 方法告诉程序queue写入完毕开始执行队例。 记得将basic_worker() 方法内的代码替换为你所需要执行的任务代码即可。</description></item><item><title>易语言-&gt;编程基础知识-&gt;数据类型</title><link>https://arae.cc/post/25761.html</link><pubDate>Wed, 20 Sep 2017 18:59:29 +0800</pubDate><guid>https://arae.cc/post/25761.html</guid><description>数据类型： 各种数值的数据都在内存中占用一定的存储空间。字节（byte) 是系统中最基本存储单位。数据类型所占字节数越多，所能够容纳数值的范围就越大。 数据类型的概念： 数据：是指能够输入到计算机中，并能够被计算机识别和加工处理的符号的集合，是程序处理的最小对象。例如：数值、字符、图形、图像和声音等都是数据。数据在程序中以常量或变量的方式被引用，不同的数据特点有不同的存储要求和处理算法。 上小学时，我们学过自然数，小数，分数等，其中，1,2,3这样的数叫自然数；-2，-1，0，1，2等的数叫整数；1.1，1.3，1.4，1.66这样的数叫小数。把数据进行这样的区分，在电脑语言里被称做数据类型。 易语言的数据类型从数据结构来区分，可分为基本数据类型、特殊数据类型。 基本数据类型有6种，包括数值型、逻辑型、日期时间型、文本型、字节集型、子程序指针型。 数值型数据又包括了字节型、短整数型、整数型、长整数型、小数型、双精度小数型。数值型数据都是由0-9数字，小数点组成的一个数值。 常用数据类型： 数据类型名称 占用字节 取值范围 字节型 1 0 ～ 255 短整数型 2 -32,768 ～ 32,767 整数型 4 -2,147,483,648 ～ 2,147,483,647 长整数型 8 -9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807 小数型 4 -3.4E38 ～ 3.4E38 (7位小数) 双精</description></item><item><title>计算机更新这么快，怎么编程语言还是二十多年前的？</title><link>https://arae.cc/post/25753.html</link><pubDate>Sat, 22 Oct 2016 20:13:36 +0800</pubDate><guid>https://arae.cc/post/25753.html</guid><description>刚刚看了《Hackers &amp;amp; Painters》觉得里面讲lisp语言未来会流行的那部分理论很有意思，也很有说服力。 下面讲讲我自己的想法： 机器性能本身是贬值的，按照摩尔定律，平均过去大约是每过18个月就能以原先一半的价钱买到相同性能的CPU，相对于这种贬值速度，人力资源的价值可以认为是固定不变的，也就是说人力资源相比于机器性能的价值越来越高。 所以人们在开发软件的过程中，相比于过去，越来越不重视代码的优化，具体可以参见Andy and Bill’s Law。 但是按这种逻辑，编程语言也会越来越接近自然语言，学习门槛越来越低，但是运行性能也越来越低。可是目前流行的编程语言都是很早以前发明的，都是设计给那时候的计算机运行的，为什么它们没有被现在发明的语言所淘汰？ 各种热门语言的发明时间(排名不分先后，也未包含所有热门编程语言)： Python 1991 Java 1995 Ruby 1990 PHP 1994 Javascript 1995 R 1993 而且奇怪的是这几种语言都集中在1990～1995之间。 发明得早的语言，并不等于为当时的机器设计的语言。发明得早的语言，现在还活跃的并不是它的最初版，而是持续改进后的成果。事实上，过去编程语言流行有过三次浪潮，驱动力各不相同。 第一波是50~70年代，这一波是数学驱</description></item><item><title>易语言 取自定义数据类型的大小</title><link>https://arae.cc/post/25744.html</link><pubDate>Sat, 10 Sep 2016 01:37:11 +0800</pubDate><guid>https://arae.cc/post/25744.html</guid><description>先说一下易语言的变量储存机制 易语言有基本数据类型和复合数据类型两种 基本数据类型包括：1. 各种整数 2.各种浮点 3. 逻辑值 他们都是储存在栈上的 大小都是固定的 用不着取 复合类型一般储存在堆上 然后在栈上储存堆上数据的引用 其中有几种比较特殊：字符串 字节集 数组 这两种类型的大小虽然储存在堆上的某个地方 但都有专门的取大小函数 直接调用即可 剩下就是自定义数据类型 比如类或者结构 特别是类 类的数据成员都是私有的 假如你想知道别人写的一个模块里一个类的大小 不可能通过数数据成员的方法得到 那如何取到呢？有人可能提出用“取变量地址”这个函数 可惜的是 “取变量地址”取到的永远是栈上的地址 根据上面所说 栈上地址的内容就是堆上地址 但是易语言没有一个用指针取整数的函数 这就需要用一个系统api：RtlMoveMemory 这个函数跟c语言memcpy的功能一样 但是有了他问题就变得容易的多 声明一个整形变量a q是一个自定义的类或者结构 RtlMoveMemory (取变量地址 (a), 取变量地址 (q), 4) 这样a储存的就是ls在堆区的地址 之后用到一个api：LocalSize 我们都知道堆区内存分配必然用到LocalAlloc/GlobalAlloc 那么也能通过LocalSize取到大小 调</description></item><item><title>常用Windows消息、常量命名参考</title><link>https://arae.cc/post/25717.html</link><pubDate>Thu, 14 Jul 2016 21:22:27 +0800</pubDate><guid>https://arae.cc/post/25717.html</guid><description>在WIN系统常量里，一般会以两到三个字母加个下划线作为前缀，从这些前缀里就能知道是什么类型的常量。 一般情况下，第一个字母为控件的头一个字母，第二个字母是M的是消息(Message)常量，S是风格(Style)常量，N是通知、事件(Notify)。 下面列出一些常量的常量前缀，为大家以后使用API、常量等带来方便。 以下内容由(彬·泪闯天涯)整理，如果发现有什么错误请指正。 如果是使用VB、易语言等需要自己声明常量的开发工具，可以下载一些工具来查询、复制。 a b c WM_ Window Message 窗口消息，一般用在SendMessage，PostMessage这样的消息函数中 SM_ Static Message 静态标签消息 SS_ Static Style 静态标签风格 BM_ Button Message 按钮消息 BS_ Button Style 按钮风格 BN_ Button Notify 按钮通知 EM_ Edit Message 编辑框消息 ES_ Edit Style 编辑框风格 CB_ ComboBox 组合框消息 CBN_ ComboBox Notify 组合框通知 LBM_ ListBox Message 列表框消息 LBS_ ListBox Style 列表框风格 LBN_ ListBox Notify 列表框通知 LVM_ ListView Message 超级列表框(列表视图)消息 LVS_ ListView Style 超级列表框(列表视图)风格 LVN_ ListView Notify 超级列表框(列表视图)通知 TVM_ TreeView Message 树型框(树型视图)消息 TVS_ TreeView Style 树型框(树型视图)风格 TVN_ TreeView Notify 树型框(树型视图)通知 VK_ Virtual Keyboard 虚拟键、键代码</description></item><item><title>易语言程序加密的原则</title><link>https://arae.cc/post/25710.html</link><pubDate>Thu, 14 Jul 2016 10:48:03 +0800</pubDate><guid>https://arae.cc/post/25710.html</guid><description>早先人们的加密方法是通过在软盘上格式化一些非标准磁道，在这些磁道上写入一些数据，如软件的解密密钥等等。这种软盘成为“钥匙盘”。软件运行时用户将软盘插入，软件读取这些磁道中的数据，判断是否合法的“钥匙盘”。 软盘加密还有其它一些技术，如弱位加密等等。 随着近年来软盘的没落，这种方法基本上退出了历史舞台。新的软件加密技术也越来越多了。 加密前要考虑周到且严密 说实话，有很多人在易语言论坛上发贴，说自己用易语言编写的软件有了破J，还非常高兴，有人用才会被破J，但我想，如果是很高兴的这样子，除非你的软件技术含量很低，或你是微软，想被别人破J，您不应该高兴，这有点象别人打了你一耳光，你还很高兴，你的知识产权或著作权已被奸人侵犯了，性质很恶劣，后果很严重。除了拿起法律武器，劳命伤财，还有就是加强加密方式。 如果被制作出注册机，情况是最糟糕的，作者需要全部更换全部用户的注册KEY文件，工作量相当地相当地大。因此一个好的软件保护发布前必须考虑周到，而且是面面俱到，否则出一个新版，发现一个破J，再出一个新版去修正，那样的事情是极其弱智的。 需要加密的内容要制定一个计划 一开始不明白如何加密的易语言用户，一般就找一下论</description></item><item><title>[教程]防止模块被反编译的有效方法（吴总提供）：</title><link>https://arae.cc/post/25703.html</link><pubDate>Tue, 12 Jul 2016 13:50:53 +0800</pubDate><guid>https://arae.cc/post/25703.html</guid><description>防止模块被反编译的有效方法: 请在模块中建立一个或多个窗口,将其&amp;rdquo;可视&amp;rdquo;属性设置为假,窗口上放一些随机类型的组件(尽量不要用常用组件),重要数据分散放在这些组件的属性里面,模块中的代码动态载入这些窗口,从这些组件属性中读入相关数据使用. 原理: 由于易语言有相当多类型的组件,而每个组件的属性数据保存格式都不一样,模块反编译想把每种组件中的属性数据反编译出来具有相当的难度,所以数据放在组件属性里面是安全的.</description></item><item><title>[转]易语言 360免杀方法心得总结</title><link>https://arae.cc/post/25701.html</link><pubDate>Mon, 11 Jul 2016 16:22:14 +0800</pubDate><guid>https://arae.cc/post/25701.html</guid><description>易语言有一些命令是一定会被拦截的。比如访问网页，文件读写。 因为白名单系统，特征码修改的方法变的越来越鸡肋了。 推荐自己的方法。 1.源码定位，首先删减源码，然后编译，如果报毒，继续删减，直到不报毒为止，定位出报毒的子程序。然后删减子程序的命令，进行编译，最终定位出报毒的命令。（大型软件就算了，代码太多，太费事） 2.在敏感代码前后，子程序前后，添加大量无意义的不报毒命令。例如循环1000次判断计算加减乘除运算。跳来跳去。 3.编译后替换资源，建议替换360相关产品（非杀毒卫士）下带证书的资源，最好是dll文件。越大越好。 4.压缩壳或者加密壳，建议upx压缩壳最高压缩。因为upx比较好脱壳，所以不容易报毒。加密壳推荐Themida 强壳暂时可以直接过。以前se壳比较牛，因为太牛了，所以360直接报。 5.体积膨大，这个比较有意思，在一定程度上可以阻止360上传检测。如果不介意，最好把自身膨大到1G以上。 程序中写入自我膨胀最好。膨胀还有一个好处，就是能够改变自身md5值，最好设置成随机体积。 6.先膨胀再压缩，也就是上面4和5颠倒一下。换完资源就膨胀，然后再压缩。 总结的都是一些菜鸟免杀思路，技术有限也研</description></item><item><title>易语言程序防破解的常用方法</title><link>https://arae.cc/post/25675.html</link><pubDate>Mon, 11 Jul 2016 15:52:50 +0800</pubDate><guid>https://arae.cc/post/25675.html</guid><description>用易语言写过好几个软件了，有些软件也被破解过，想想也是正常的，前几年我也破解别人的软件来着，呵呵！ 也正是因为有过破解软件的经验，所以在防破解这一块的学习上，就觉得很简单了，下面我把我的一些常用经验说一下，有兴趣的朋友可以试一下，呵呵，先说明啊，下面说的只是我的个人经验，大家想比较系统的学习的话，最好是找一些相对专业的教程来看看。 花指令的插入，这当然是有必要的，有人说加了花指令没有什么用，现在的反编译软件基本上都有去除花指令的功能，但是难度它能去我就不加了，给破解者增加一点麻烦事也是好的嘛！ 加壳，现在的很多壳都有自动脱壳工具，那这个壳是加还是不加呢？和上面第一点的理由一样，加！一定要加，你不想你的程序成为初学破解者用来练手吧。 注册方式的选择，就最常用的注册而言，还得是硬件码+注册码的形式，其它的加密狗、网络验证等方式还是没办法普及！ 加密算法的选择，千万别自己写加密算法，如把硬件码拆开，位移，计算，***，最后得到注册码，可以很明确的告诉你，这样做的话，注册机迟早会出现。 选择一些相对成熟的算法，比如说RSA之类的，下一节我们会专门来学习一个RSA的使用。 程序中如何验证注册码，千万别来一个判</description></item><item><title>“大牛”不可缺少的三种文献精读思维模式</title><link>https://arae.cc/post/25631.html</link><pubDate>Sun, 03 Jul 2016 19:44:50 +0800</pubDate><guid>https://arae.cc/post/25631.html</guid><description>文献精读是科研人必不可少的功课。精读的主要目的是要把文章的内容真正消化掉，要转化为你自己可以运用的东西。精读的方式分为三种，它们包括“验证型阅读”、“挑刺型阅读”和“总结归纳型阅读”。 验证型阅读——模仿者 这时候，你的角色是一个模仿者。就是拿到一篇好文章，暂不看文字内容，先把图和表挑出来，根据图和表的内容想想你来写这篇文章，你会怎么写，包括大的结构框架、组织逻辑，以及如何引入问题，如何进行结果陈述，如何引申出结论等，然后再看作者是怎么做的，反复体会你想的和你看的有哪些不同。当你的想法和作者的雷同程度越来越高，你的水平也在不知不觉之中越来越高。 这种“图表——思索——验证”的阅读对提升思维非常有效。当你做实验后得到的就是几个表、几个图，如果有意识地经过了“验证型阅读”的训练，你就会知道该怎么从更高、更好的角度来写你的文章。同样的数据，有的人可以发10.0的文章，有的人可能只能发5.0的文章，为什么有这种差别？这种差别其实就是在平时阅读文献的过程中慢慢积累出来的。 &amp;nbsp;挑刺型阅读——评论者&amp;nbsp; 这时候，你的角色相当于一个评论者了。是一种更高层次的精读方式，需要有评论的一些基础。挑刺</description></item><item><title>【WebKit内核】EasyCKL开源浏览器库 6.1 支持调试运行了</title><link>https://arae.cc/post/25632.html</link><pubDate>Sat, 25 Jun 2016 14:33:50 +0800</pubDate><guid>https://arae.cc/post/25632.html</guid><description>下面是原作者的介绍 &amp;gt;EasyCKL是一款基于某开源浏览器内核的浏览器库，使用C/C++编写，为易语言提供web浏览框的库。EasyCKL是phewyyx编写发布。 EasyCKL基于国际领先的开源浏览器内核，支持HTML5等现代web标准，同时兼容XP、Vista、7、8、8.1、10操作系统，比超文本框具有兼容性好，速度快，支持新web标准等优点。 /&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 链接: http://pan.baidu.com/s/1o89xgMI 密码: vt73</description></item></channel></rss>