<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code on ARAE</title><link>https://arae.cc/tags/code.html</link><description>Recent content in Code on ARAE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 15 Jun 2018 15:26:38 +0800</lastBuildDate><atom:link href="https://arae.cc/tags/code/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript如何判断变量是数组还是对象</title><link>https://arae.cc/post/25792.html</link><pubDate>Fri, 15 Jun 2018 15:26:38 +0800</pubDate><guid>https://arae.cc/post/25792.html</guid><description>方法一 通过判断变量的类型，并且变量的length属性(除了有一种例外是arguments对象–当给函数传参时数据存储的地方) var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(typeof arr); //object console.log(typeof obj); //object console.log(arr.length); //3 console.log(obj.length); //undefined console.log(obj.name); //maomao //这里说明在对象中并没有length属性，所以是未定义。 方法二 使用toString方法将对象转换成其他类型的string，该例很好的证明了arguments对象不是数组，而是对象 var arr=[2,3,4]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; // console.log(arr.toString()); //&#39;2,3,4&#39; // console.log(obj.toString()); //[object Object] function sum(a,b){ // console.log(arguments); // console.log(typeof arguments); //object // console.log(arguments.length); //2 根据具体调用函数传的实参决定 // console.log(arguments.toString()); //[object Arguments] return a+b; } alert(sum(3,4)); 方法三 —&amp;gt;不可行 instanceof 指出对象是否是特定类的一个实例。 结论:instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(arr instanceof Array); //true console.log(obj instanceof Object); //true console.log(arr instanceof Object); //true // ---这里跟网上的不同，不知道是什么原因 console.log(obj instanceof Array); //false 方法四 ECMAScript 5中可以使用isArray来判断 var arr=[2,3,4,&amp;quot;haa&amp;quot;]; var obj={&amp;quot;name&amp;quot;:&amp;quot;maomao&amp;quot;,&amp;quot;age&amp;quot;:20}; console.log(Array.isArray(arr)); //true console.log(Array.isArray(obj)); //false //注意没有isObject这种方法 暂时 方法五 使用isPrototypeOf()函</description></item><item><title>Bing每日壁纸API接口「十个国家版本」</title><link>https://arae.cc/post/25782.html</link><pubDate>Wed, 14 Mar 2018 23:49:26 +0800</pubDate><guid>https://arae.cc/post/25782.html</guid><description>前言 (瞎BB..) 这次在原有的国内版(中国)、国际版(美国)基础上又加了日本、印度、巴西、法国、德国、加拿大、澳大利亚、英国八个地区版本，不过就是图片重复率有点高，建议随便选个一直用@pp{你懂的} 接口在调用的时候空参数默认为「国际版(美国)302到图片地址」，而且POST方法仅支持返回JSON。 接口(API) 接口： //api.arae.cc/?p=bing 参数： s 地区版本，默认 0 ，可空 0 =&amp;gt; 美国 EN-US 1 =&amp;gt; 中国 ZH-CN 2 =&amp;gt; 日本 JA-JP 3 =&amp;gt; 印度 EN-IN 4 =&amp;gt; 巴西 PT-BR 5 =&amp;gt; 法国 FR-FR 6 =&amp;gt; 德国 DE-DE 7 =&amp;gt; 加拿大 EN-CA 8 =&amp;gt; 澳大利亚 EN-AU 9 =&amp;gt; 英国 EN-GB code json = 返回utf8 json数据(包括日期、地址、说明); null/undefined 或 其他则自动302到图片地址(可直接img标签调用); key 其实这个打算写出来自己用的，如果想用可以到留言板留言...具体格式参照api.arae.cc首页申请格式.. 返回参数说明 { &amp;quot;time&amp;quot;:&amp;quot;20180313&amp;quot;, /* 时间 */ &amp;quot;startdate&amp;quot;:&amp;quot;2018-03-13&amp;quot;, /* 开始时间 */ &amp;quot;enddate&amp;quot;:&amp;quot;2018-03-14&amp;quot;, /* 结束时间 */ &amp;quot;region&amp;quot;:&amp;quot;ZH-CN&amp;quot;, /* 缩写 */ &amp;quot;url&amp;quot;:&amp;quot;***.jpg&amp;quot;, /* 图片链接 */ &amp;quot;text&amp;quot;:&amp;quot;****&amp;quot; /* 图片相关说明 */ } 调用方法 GET: 返回 「中国版」 json数据(utf8) //api.arae.cc/?p=bing&amp;amp;code=json&amp;amp;s=1 { &amp;quot;time&amp;quot;:&amp;quot;20180313&amp;quot;, &amp;quot;startdate&amp;quot;:&amp;quot;2018-03-13&amp;quot;, &amp;quot;enddate&amp;quot;:&amp;quot;2018-03-14&amp;quot;, &amp;quot;region&amp;quot;:&amp;quot;ZH-CN&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/ToroidalBubble_ZH-CN10711997835_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;小巴哈马浅滩中的大西洋花斑原海豚和气泡环，巴哈马 (© Hiroya Minakuchi/Minden Pictures)&amp;quot; } 返回 「美国版」 json数据(utf8) //api.arae.cc/?p=bing&amp;amp;code=json { &amp;quot;time&amp;quot;:&amp;quot;20180314&amp;quot;, &amp;quot;startdate&amp;quot;:&amp;quot;2018-03-14&amp;quot;, &amp;quot;enddate&amp;quot;:&amp;quot;2018-03-15&amp;quot;, &amp;quot;region&amp;quot;:&amp;quot;EN-US&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/ToroidalBubble_EN-US9481815479_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;Atlantic spotted dolphins</description></item><item><title>Bing每日图片(壁纸)API接口</title><link>https://arae.cc/post/25776.html</link><pubDate>Tue, 27 Feb 2018 00:22:20 +0800</pubDate><guid>https://arae.cc/post/25776.html</guid><description>前言 (瞎BB..) [NEW] Bing每日壁纸API接口「十个国家版本」 Bing图片每日更新，对于这一点感觉挺不错的，如果能够把Bing每日图片作为博客背景是不是很不错呢？ 在用的时候注意区分下国内版跟国际版，有时候图片一样，但是描述全是鸟文&amp;hellip; 接口在调用的时候空参数默认为(国内版302到图片地址)，而且POST方法仅支持返回JSON。 接口(API) 接口： //api.arae.cc/?p=bing 参数： s 1 = 国内; null/undefined 或 其他值:国际版; code json = 返回utf8 json数据(包括日期、地址、说明); null/undefined 或 其他则自动302到图片地址(可直接img标签调用); key 其实这个打算写出来自己用的，如果想用可以到留言板留言...具体格式参照api.arae.cc首页申请格式.. PS:分辨率是 1920x1080 调用方法 GET: 返回 [国内版] json数据(utf8) //api.arae.cc/?p=bing&amp;amp;s=1&amp;amp;code=json { &amp;quot;time&amp;quot;:&amp;quot;20180226&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/CactiIslaPescado_ZH-CN11317505000_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;玻利维亚乌尤尼盐湖的仙人掌岛 (? Alex Saberi/Getty Images)&amp;quot; } 返回 [国际版] 版json数据(utf8) //api.arae.cc/?p=bing&amp;amp;code=json { &amp;quot;time&amp;quot;:&amp;quot;20180226&amp;quot;, &amp;quot;url&amp;quot;:&amp;quot;https://www.bing.com/az/hprichbg/rb/WoolBaySeadragon_EN-US12559454946_1920x1080.jpg&amp;quot;, &amp;quot;text&amp;quot;:&amp;quot;A leafy seadragon in the waters off Wool Bay, Australia (? Alex Mustard/Minden Pictures)&amp;quot; } 返回 [国内版] 图片 //api.arae.cc/?p=bing&amp;amp;s=1 Html: &amp;lt;img src=&amp;quot;//api.arae.cc/?p=bing&amp;amp;s=1&amp;quot; title=&amp;quot;Bing每日图片(壁纸) 国内版&amp;quot;&amp;gt; Markdown: ![&amp;quot;Bing每日图片(壁纸) 国内</description></item><item><title>注释用的好，可能会挨打！？</title><link>https://arae.cc/post/25773.html</link><pubDate>Fri, 23 Feb 2018 17:19:04 +0800</pubDate><guid>https://arae.cc/post/25773.html</guid><description>一、概述 这是写在前面的话：在开发中的时候，应该、可能、或许会看到有趣的注释 遇到类似的注释能让开发更加的有乐趣，我提倡程序猿继续传承下去这个美好优良传统 二、正文 比如： /** * 描述：XXXX &amp;lt;br&amp;gt; * 作者： XXXX &amp;lt;br&amp;gt; * E-mail: XXXX &amp;lt;br&amp;gt; * 日期： XXXX 下午XXXX &amp;lt;br&amp;gt; */ public class Points implements Serializable { private static final long serialVersionUID = 1L; /** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&amp;quot; &amp;quot;-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &amp;gt; &amp;quot;=._ | )(__/ \__)( | _.=&amp;quot; &amp;lt; | * * | (_/&amp;quot;=._&amp;quot;=._ |/ /\ \| _.=&amp;quot;_.=&amp;quot;\_) | * * | &amp;quot;=._&amp;quot;(_ ^^ _)&amp;quot;_.=&amp;quot; | * * | &amp;quot;=\__|IIIIII|__/=&amp;quot; | * * | _.=&amp;quot;| \IIIIII/ |&amp;quot;=._ | * * | _ _.=&amp;quot;_.=&amp;quot;\ /&amp;quot;=._&amp;quot;=._ _ | * * | ( \_.=&amp;quot;_.=&amp;quot; `--------` &amp;quot;=._&amp;quot;=._/ ) | * * | &amp;gt; _.=&amp;quot; &amp;quot;=._ &amp;lt; | * * | (_/ \_) | * * | | * * &#39;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#39; * * * * LASCIATE OGNI SPERANZA, VOI CH&#39;ENTRATE * ************************************************************** */ /** * 请不要尝试修改属性lng和lat为别的数据类型，相信我，改了之后，你会后悔的。 * 至于原因，创建的时候我应该知道，现在只剩下上帝知道 */ private Integer id; private String markerId; // 标识符 private double lng; private double lat; private String type; private Integer status = 0; // 覆盖物状态：0未添加，1已添加，2已添加并且是已发送的覆盖物 默认值：0 private List&amp;lt;Points&amp;gt; list = new ArrayList&amp;lt;Points&amp;gt;(); ...... 再或者在结尾处加 /* * ┏┓ ┏┓ *┏┛┻━━━┛┻┓ *┃ ┃ *┃ ━ ┃ *┃ ┳┛ ┗┳ ┃ *┃ ┃ *┃ ┻ ┃ *┃ ┃ *┗━┓ ┏━┛ * ┃ ┃神兽保佑 * ┃ ┃代码无BUG！ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫</description></item><item><title>jquery判断图片或者背景图片加载完毕</title><link>https://arae.cc/post/25771.html</link><pubDate>Thu, 15 Feb 2018 13:37:24 +0800</pubDate><guid>https://arae.cc/post/25771.html</guid><description>前端开发制作中有需要需要等到页面中的图片加载完毕后才执行某些事件，而使用jquery的load事件只是dom执行完毕，图片未必加载完成，如果要判断图片加载完毕，需要在图片标签上判断。 使用JavaScript判断图片加载完毕，如果图片在页面中的某个img标签中的话，可以用下面这个 $(&#39;img&#39;).on(&#39;load&#39;, function() { alert(&#39;new image loaded: &#39; + this.src); }); 原生js imgNode.onload = () =&amp;gt; { alert(&#39;new image loaded: &#39; + this.src); }; （1）、单张图片（图片在文档中） // HTML &amp;lt;img id=&#39;pic&#39; src=&amp;quot;../03.png&amp;quot;&amp;gt; //js $(document).ready(function(){ //jquery $(&#39;#pic&#39;).load(function(){ // 加载完成 }); //原生 onload var pic = document.getElementById(&#39;pic&#39;) pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; }) 注： 1、IE8及以下版本不支持onload事件，但支持onreadystatechange事件； 2、readyState是onreadystatechange事件的一个状态，值为loaded或complete的时候，表示已经加载完毕。 3、如果引入jquery库可以考虑直接使用jquery的load事件来解决兼容问题。 （2）、单张图片（图片动态生成） //js var pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = pic.onreadystatechange = function(){ if(!this.readyState||this.readyState==&#39;loaded&#39;||this.readyState==&#39;complete&#39;){ // 加载完成 } }; //jquery $(&#39;&amp;lt;img/&amp;gt;&#39;).attr(&#39;src&#39;, &#39;../03.png&#39;).on(&#39;load&#39;, function() { $(this).remove(); // 防止内存泄露 //图片加载完毕 }); （3）、单张图片（结合ES6 Promise） //js new Promise((resolve, reject)=&amp;gt;{ let pic = new Image() pic.src = &#39;../03.png&#39; pic.onload = function(){ // 加载完成 resolve(pic) } }).then((pic)=&amp;gt;{ //code }) （4）、多张图片 var img = [], flag = 0,</description></item><item><title>颜值测试API，微软小冰颜值，颜值API</title><link>https://arae.cc/post/25740.html</link><pubDate>Wed, 17 Aug 2016 14:56:22 +0800</pubDate><guid>https://arae.cc/post/25740.html</guid><description>微软小冰颜值api http://kan.msxiaobing.com/Api/ImageAnalyze/Process?service=yanzhi 在使用前我们看一下效果 {&amp;quot;msgId&amp;quot;:&amp;quot;1461905520063&amp;quot;,&amp;quot;timestamp&amp;quot;:0,&amp;quot;receiverId&amp;quot;:null,&amp;quot;content&amp;quot;:{&amp;quot;text&amp;quot;:&amp;quot;颜值7.2分，再接再厉！捯饬捯饬，说不定就是男神了呢~&amp;quot;,&amp;quot;imageUrl&amp;quot;:&amp;quot;http:\\\\/\\\\/mediaplatform.trafficmanager.cn\\\\/image\\\\/fetchimage?key=UQAfAC8ABAAAAFcAFgAGABYASgBAADgAMQBFAEQARABGAEEAMgBGADkAQgBGAEYAQwA4AEEANQAxADgAMAA4AEEANgA2ADMAMwBFADMAMAA3AEEA&amp;quot;,&amp;quot;metadata&amp;quot;:{&amp;quot;w&amp;quot;:&amp;quot;scv9isnfUnZbhOfPjNnUjOfir-3Ave_sisfqiuTo</description></item><item><title>时钟事件执行时间超出时钟周期问题解释</title><link>https://arae.cc/post/25737.html</link><pubDate>Thu, 21 Jul 2016 14:13:58 +0800</pubDate><guid>https://arae.cc/post/25737.html</guid><description>时钟组件 作为定时器 系统会在设定时间发送 WM_TIMER 消息给消息队列，因为事件处理函数和窗口回调函数都是同线程， 在一个消息未处理完返回之前是不能处理其他事件消息的，也就是一个时钟事件函数未执行完返回之前，系统是不会发送下一个 WM_TIMER 消息到消息队列中的，所以第二个WM_TIMER消息也就是会被忽略掉。 将时钟周期设置为500 1.下面这个例子你会发现 a 和b是同步的数值是相等的就是这个道理 .局部变量 a, 整数型, 静态 .局部变量 b, 整数型, 静态 a ＝ a ＋ 1 调试输出 (“a”, a) 延时 (1000) b ＝ b ＋ 1 调试输出 (“b”, b) 2.第二个例子很有意思，你会发现程序一直在输出a ，而没有输出b，呵呵，你来猜猜是什么原因？ .局部变量 a, 整数型, 静态 .局部变量 b, 整数型, 静态 a ＝ a ＋ 1 调试输出 (“a”, a) 延迟 (1000) b ＝ b ＋ 1 调试输出 (“b”, b) 第二个例子 和第一个例子的区别是把延时（）换成了延迟（），想来看看这两个命令的作用和区别，他们的区别一个是相当于暂停当前线程向下执行，等待设定长时间后在向下执行，但并不处理事件消息； 另一个是在等待中并且处理事件消息。那么为什么会出现这样的结果呢，首先来看一下延迟（）命令 他是在等待中处理消息队列中未决的消息，那么WM_T</description></item><item><title>Markdown 语法整理</title><link>https://arae.cc/post/25645.html</link><pubDate>Thu, 01 Jan 1970 01:00:00 +0800</pubDate><guid>https://arae.cc/post/25645.html</guid><description>概述 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 标题 Code # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 ####### h7 // 错误代码 ######## h8 // 错误代码 ######### h9 // 错误代码 ########## h10 // 错误代码 Demo 注：h1最大，h6最小 分级标题 Code 注：= - 最少可以只写一个，兼容性一般 一级标题 ====================== 二级标题 --------------------- Demo TOC Code 注：根据标题生成目录，兼容性一般 [TOC] Demo 引用 Code &amp;gt; hello world! Demo hello world! Code-2 [多行式] &amp;gt; hello world! hello world! hello world! 或者 &amp;gt; hello world! hello world! hello world! Demo-2 [多行式] 结果相同 hello world! hello world! hello world! Code-3 [多层嵌套] &amp;gt; aaaaaaaaa &amp;gt;&amp;gt; bbbbbbbbb &amp;gt;&amp;gt;&amp;gt; cccccccccc Demo-3 [多层嵌套] aaaaaaaaa bbbbbbbbb cccccccccc Code-4 [多层多个元素] 注：代码前 3个</description></item></channel></rss>